[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is my personal site for the course Introduction to Systems Biology (BSc/MSc). I’m collecting my exercise solutions here. The code isn’t meant to be perfect—it’s a working record of my learning process, to consolidate material and maybe help others following along."
  },
  {
    "objectID": "nbs/week1-igraph.html",
    "href": "nbs/week1-igraph.html",
    "title": "Week 1: Introduction to igraph",
    "section": "",
    "text": "TASK: Make a simple network in igraph\n\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\nlibrary(ggraph)\n\nLoading required package: ggplot2\n\nlibrary(tidygraph)\n\n\nAttaching package: 'tidygraph'\n\n\nThe following object is masked from 'package:igraph':\n\n    groups\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\n\nhemoglobin &lt;- data.frame(from = c(\"ALPHA_GLOBIN\", \"ALPHA_GLOBIN\", \"BETA_GLOBIN\"), to = c(\"ALPHA_GLOBIN\", \"BETA_GLOBIN\", \"BETA_GLOBIN\"))\ng &lt;- graph_from_data_frame(hemoglobin, directed = FALSE, vertices = NULL)\nplot(g)\n\n\n\n\n\n\n\n\n\nMake sure you understand what the NODES (the circles) and the EDGES (the lines) represent: what is the BIOLOGICAL interpretation of the network?\nIn this protein-protein interaction graph, each node represents a protein and each edge represents interaction between them.\n\nTASK: create data frame for the polymerase sub-unit interactions and add attributes to igraph object:\n\npolymerase_subunit &lt;- data.frame(from = c(\"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD3_HUMAN\"), to = c(\"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"DPOD4_HUMAN\"))\nps_attr &lt;- data.frame(name = c(\"DPOD1_HUMAN\", \"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\"), GeneID = c(\"PolD1\", \"PolD2\", \"PolD3\", \"PolD4\"), Catalytic = c(\"yes\", \"no\", \"no\", \"no\"), Description = c(\n    \"DNA polymerase delta catalytic subunit\",\n    \"DNA polymerase delta subunit 2\",\n    \"DNA polymerase delta subunit 3\",\n    \"DNA polymerase delta subunit 4\"\n), AA = c(1009, 469, 466, 107))\np &lt;- graph_from_data_frame(polymerase_subunit, directed = FALSE, vertices = ps_attr)\nplot(p)\n\n\n\n\n\n\n\nV(p)$Description\n\n[1] \"DNA polymerase delta catalytic subunit\"\n[2] \"DNA polymerase delta subunit 2\"        \n[3] \"DNA polymerase delta subunit 3\"        \n[4] \"DNA polymerase delta subunit 4\"        \n\n\nTASK - use the node annotations for customizing visualization\n\nggraph(p) +\n    geom_edge_link() +\n    geom_node_point()\n\nUsing \"stress\" as default layout\n\n\n\n\n\n\n\n\n\nWay to visualize protein-protein interactions? Definetly not – not a lot of information is represented.\n\nggraph(p) + geom_edge_link() + geom_node_point(aes(colour = Catalytic, size = AA)) + geom_node_text(aes(label = name), repel = TRUE)\n\nUsing \"stress\" as default layout\n\n\n\n\n\n\n\n\n\n\nExtended Pol δ network\nFor the final part of the exercise we’ll be working with set of experimental data centered around the Pol δ complex. Later in the course we will learn a lot of details about how such experimental data is generated, what strengths and weaknesses the different methods have, and how we can address the noise in the data.\nFor now it sufficient to note the following:\n\nThe experiment has detected proteins that physically interacts with the PolD1-PolD4 complex we have just worked with.\nBoth stable and transient interactions have been identified.\nThe experiment shows some of the most likely interactions - additional experiments may find more.\nThe data may contain false positive (proteins indicated to interact, while that is not true under real biological conditions).\n\n\npoldelta_extented_interactions &lt;- data.frame(from = c(\"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD3_HUMAN\", \"DPOD3_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"DPOD4_HUMAN\", \"DPOD4_HUMAN\", \"DPOD4_HUMAN\", \"PRI1_HUMAN\", \"WRIP1_HUMAN\"), to = c(\"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"S7A6O_HUMAN\", \"TREX2_HUMAN\", \"DNA2L_HUMAN\", \"PRI1_HUMAN\", \"PRI2_HUMAN\", \"WRIP1_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"PDIP2_HUMAN\", \"BACD1_HUMAN\", \"WRIP1_HUMAN\", \"DNA2L_HUMAN\", \"PRI1_HUMAN\", \"PRI2_HUMAN\", \"DPOD4_HUMAN\", \"DNA2L_HUMAN\", \"PRI1_HUMAN\", \"PRI2_HUMAN\", \"DNA2L_HUMAN\", \"PRI1_HUMAN\", \"PRI2_HUMAN\", \"WRIP1_HUMAN\", \"PRI2_HUMAN\", \"WRIP1_HUMAN\"), confidence = c(1.00, 1.00, 1.00, 0.18, 1.00, 1.00, 1.00, 1.00, 0.52, 1.00, 1.00, 1.00, 1.00, 0.54, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.57, 1.00, 0.65))\ne &lt;- graph_from_data_frame(poldelta_extented_interactions, directed = FALSE, vertices = NULL)\n\n\nggraph(e, layout = \"kk\") + geom_edge_link() + geom_node_point() + geom_node_label(aes(label = name), repel = TRUE)\n\n\n\n\n\n\n\n\nLinear is not a suitable layout, because it loses out on clustering of interactions.\nTASK - visualize the Node attributes\n\nNode label - use GeneID\nNode color - color based on “Role in replication” (invent your own coloring scheme)\nNode shape - pick two shapes to represent whether the protein is known to bind to DNA\nThe graph design was done with ChatGPT this time.\n\n\nextended_attr &lt;- data.frame(\n    name = c(\n        \"DPOD1_HUMAN\", \"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\",\n        \"BACD1_HUMAN\", \"DNA2L_HUMAN\", \"PDIP2_HUMAN\", \"PRI1_HUMAN\",\n        \"PRI2_HUMAN\", \"S7A6O_HUMAN\", \"TREX2_HUMAN\", \"WRIP1_HUMAN\"\n    ),\n    GeneID = c(\n        \"POLD1\", \"POLD2\", \"POLD3\", \"POLD4\",\n        \"PDIP1\", \"DNA2\", \"POLDIP2\", \"PRIM1\",\n        \"PRIM2\", \"SLC7A6OS\", \"TREX2\", \"WRNIP1\"\n    ),\n    Role_in_replication = c(\n        \"Polymerase\", \"Polymerase\", \"Polymerase\", \"Polymerase\",\n        \"Uncertain\", \"Helicase\", \"Uncertain\", \"Primase\",\n        \"Primase\", \"Uncertain\", \"DNA repair\", \"DNA repair\"\n    ),\n    Cellular_component = c(\n        \"Nucleus\", \"Nucleus\", \"Nucleus\", \"Nucleus\",\n        \"Nucleus\", \"Nucleus; Mitochondrion\", \"Nucleus\", \"Nucleus (Nucleoplasm)\",\n        \"Nucleus (Nucleoplasm)\", \"Nucleus\", \"Nucleus\", \"Nucleus\"\n    ),\n    DNA_Binding = c(\n        \"+\", \"+\", \"-\", \"-\",\n        \"-\", \"+\", \"+\", \"+\",\n        \"+\", \"-\", \"+\", \"-\"\n    ),\n    Description = c(\n        \"DNA polymerase delta catalytic subunit\",\n        \"DNA polymerase delta subunit 2\",\n        \"DNA polymerase delta subunit 3\",\n        \"DNA polymerase delta subunit 4\",\n        \"Polymerase delta-interacting protein 1\",\n        \"DNA replication helicase/nuclease 2\",\n        \"Polymerase delta-interacting protein 2\",\n        \"DNA primase small subunit\",\n        \"DNA primase large subunit\",\n        \"Probable RNA Pol II localization factor\",\n        \"3′→5′ exonuclease, DNA repair\",\n        \"Werner helicase-interacting protein 1\"\n    )\n)\n\ne &lt;- graph_from_data_frame(poldelta_extented_interactions, directed = FALSE, vertices = extended_attr)\n\nggraph(e, layout = \"kk\") +\n\n    geom_edge_link() +\n\n    # NODES\n    geom_node_point(\n        aes(\n            colour = Role_in_replication,\n            shape  = DNA_Binding\n        ),\n        size = 6\n    ) +\n    geom_node_label(aes(label = GeneID), repel = TRUE, box.padding = 0.4) +\n\n    # Node color scheme\n    scale_colour_manual(values = c(\n        \"Polymerase\" = \"steelblue\",\n        \"Primase\"    = \"forestgreen\",\n        \"Helicase\"   = \"orange\",\n        \"DNA repair\" = \"purple\",\n        \"Uncertain\"  = \"gray40\"\n    ), na.translate = FALSE) +\n\n    # Node shape scheme (+ binds DNA, – does not)\n    scale_shape_manual(values = c(\"+\" = 16, \"-\" = 15), na.translate = FALSE) +\n\n    # Optional: hide edge legends\n    guides(edge_colour = \"none\", edge_alpha = \"none\", edge_width = \"none\") +\n\n    theme_void()\n\n\n\n\n\n\n\n\nDoes it make sense that some of the proteins are not annotated to bind DNA yet are supposed to have a role in DNA replication? (For example DPOD3_HUMAN and DPOD4_HUMAN)\n\nYes, it does as some of these proteins are subunits of complexes that do bind DNA.\n“Catalytic vs accessory subunits:\n\nPOLD1 (DPOD1_HUMAN) is the catalytic subunit of DNA polymerase δ, with DNA polymerase and exonuclease domains — it binds DNA directly.\nPOLD2, POLD3, POLD4 are accessory subunits. They don’t themselves have DNA-binding motifs but they stabilize the catalytic subunit, anchor PCNA, or mediate interactions with other replication/repair factors.”\n\nEach edge in the Pol δ network represents a protein-protein interaction determined experimentally. A number of different pieces of information could potentially be associated with each interaction:\n\nExperimental method used.\nWhether the interaction is stable or transient.\nHow much experimental support is there for the interactions (e.g. a single experiment, 3 experiments or 100+ experiments).\n\n\nYou may consider the following interpretation of the score:\n\n0.0 - 0.3 : poor experimental support\n0.3 - 0.9 : “good enough” experimental support\n0.9 - 1.0 : excellent experimental support\n\nTASK - import and visualize network\n\nMake an igraph object with the interactions, edge attributes, and node attributes\nVisualize the network with ggraph, adding some formatting of the edges continuously by the confidence score (color, width, or transparency are good options)\nMake a discrete vector based on the three categories above, and add reload the igraph object. Make three different colors, widths, line types, or whatever else you can come up with to make a visually pleasing and informative visualization.\n\n\nggraph(e, layout = \"kk\") +\n    geom_edge_link(\n        aes(\n            edge_colour = confidence,\n            edge_alpha = confidence,\n            edge_width = confidence\n        )\n    ) +\n    scale_edge_colour_gradientn(\n        colours = c(\"plum1\", \"mediumpurple3\", \"purple4\"),\n        values  = c(0, 0.3, 0.9, 1),\n        name    = \"Confidence\" # name for the edge colorbar\n    ) +\n    guides(edge_colour = guide_edge_colourbar(\n        title  = \"Confidence\",\n        ticks  = TRUE,\n        breaks = c(0.15, 0.6, 0.95),\n        labels = c(\"0.0–0.3 poor\", \"0.3–0.9 good\", \"0.9–1.0 excellent\")\n    )) +\n    scale_edge_alpha(range = c(0.2, 1)) +\n    scale_edge_width(range = c(0.3, 1.5)) +\n\n    # NODES\n    geom_node_point(aes(colour = Role_in_replication, shape = DNA_Binding), size = 6) +\n    geom_node_label(aes(label = GeneID), repel = TRUE, box.padding = 0.4) +\n    scale_colour_manual(values = c(\n        \"Polymerase\" = \"steelblue\",\n        \"Primase\"    = \"forestgreen\",\n        \"Helicase\"   = \"orange\",\n        \"DNA repair\" = \"purple\",\n        \"Uncertain\"  = \"gray40\"\n    ), na.translate = FALSE) +\n    scale_shape_manual(values = c(\"+\" = 16, \"-\" = 15), na.translate = FALSE) +\n    theme_void()\n\n\n\n\n\n\n\n\nWhich do you prefer - continuous or discrete visualization of line colors? I prefer continuous\nFINAL QUESTION - Re-evaluate the three “uncertain” proteins (BACD1_HUMAN, PDIP2_HUMAN, S7A6O_HUMAN):\nConsider the following points and make a conclusion based on the combined evidence on which of the three proteins are likely to be true interaction partners:\n\nThe proteins they are interacting with.\nThe experimental support for the interactions.\nAny biological information (any hints, basically) you may have picked up from skimming through the UniProt pages for each of the three proteins.\n\nBased on the experimental evidence, BACD1_HUMAN, PDIP2_HUMAN are true interaction partners. They both also interact with DPOD2_HUMAN, which is clearly involved. BACD1_HUMAN seems to be a co-factor for DPOD2_HUMAN. But S7A6O_HUMAN does not seem to be involved as the experimental support is very weak."
  },
  {
    "objectID": "notebooks.html",
    "href": "notebooks.html",
    "title": "Notebooks",
    "section": "",
    "text": "Browse the notebooks below.\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nWeek 2: Network topology, statistics, and clustering\n\n\n\nNetwork topology\n\nClustering\n\nAdvanced Visualization\n\n\n\n\n\n\n\nSep 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1: Introduction to igraph\n\n\n\nBasics\n\nVisualization\n\n\n\nLearn the basics of network visualization with igraph for systems biology.\n\n\n\nSep 4, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "nbs/week2-louvian.html",
    "href": "nbs/week2-louvian.html",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "",
    "text": "Today we will get a bit more advanced with our use of igraph!\nIn this exercise we will use a subset of the human interaction dataset by Rual et al. (Nature.2005 Oct 20;437(7062):1173-8). The data consists of an interaction data frame (without edge annotations) and a node annotation data frame with gene names."
  },
  {
    "objectID": "nbs/week2-louvian.html#part-i.-getting-started",
    "href": "nbs/week2-louvian.html#part-i.-getting-started",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Part I. Getting started",
    "text": "Part I. Getting started\n\n# Load packages\nlibrary(igraph); library(ggraph); library(tidygraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n\nLoading required package: ggplot2\n\n\n\nAttaching package: 'tidygraph'\n\n\nThe following object is masked from 'package:igraph':\n\n    groups\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\n\nload(\"./data/exercise2.Rdata\")\n\nThis network consists of 1089 interactions observed between 419 human proteins, and is a small subset of a larger human interaction dataset. This subset consists of proteins that interact with the transcription factor TP53 (also known as P53).\nTake a moment to read about the function of TP53 by looking it up in UniProt:\n\nhttp://www.uniprot.org/uniprot/P53_HUMAN\n\nIn short, the human TP53 gene encodes cellular tumor antigen p53, a crucial transcription factor that acts as a central tumor suppressor and guardian of genomic integrity. In response to various cellular stresses such as DNA damage, oncogene activation, hypoxia, or oxidative stress, p53 becomes stabilized and activated through post-translational modifications that prevent its normal rapid degradation. Once active, it binds specific DNA response elements to regulate a large network of target genes involved in cell cycle arrest (e.g. via p21/CDKN1A), DNA repair (e.g. GADD45), senescence, and apoptosis (e.g. BAX, PUMA, NOXA). This coordinated response allows cells either to pause and repair their DNA or, if damage is irreparable, to undergo programmed cell death, thus preventing the propagation of potentially oncogenic mutations. Because of this role, p53 is often called the “guardian of the genome.” Inactivation or mutation of TP53—commonly seen in over half of human cancers—disrupts these protective pathways, enabling unchecked cell proliferation and genomic instability, which significantly contributes to tumorigenesis."
  },
  {
    "objectID": "nbs/week2-louvian.html#part-ii.-network-layout-and-selecting-nodes",
    "href": "nbs/week2-louvian.html#part-ii.-network-layout-and-selecting-nodes",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Part II. Network layout and Selecting nodes",
    "text": "Part II. Network layout and Selecting nodes\nTASK: Explore network layouts\nSo, now here I show two different layouts for the same network. The first is fr (Fruchterman–Reingold layout), and the second is kk (Kamada–Kawai layout) – ggraph(n, layout = “fr”) and ggraph(n, layout = “kk”). Both are quit messy – hairballs. Really difficult to see anything meaningful without analysis. But either way, with kk we can sort of see some hubs in the center, but it does look a bit more messy, while with fr, the plot looks more spaced out, with slightly more comprehensible peripheral nodes. In this case, I prefer fr.\nHere is a little information from ChatGPT about both layouts:\nName: Kamada–Kawai algorithm (kk)\nHow it works:\n\nTreats the graph like a spring system.\nEach pair of nodes has an “ideal” distance based on their graph-theoretic shortest path distance.\nThe algorithm minimizes the difference between ideal and actual distances.\n\nEffect:\n\nProduces fairly symmetrical and uniformly spaced graphs.\nWorks especially well for smaller networks (tens–hundreds of nodes).\n\nName: Fruchterman–Reingold algorithm (fr)\nHow it works:\n\nAlso uses a force-directed model:\n\nconnected nodes attract each other\nall nodes repel each other like charged particles\n\nThe system iteratively simulates forces until it reaches equilibrium.\n\nEffect:\n\nTends to produce clustered, organic “clouds”.\nWorks well for larger networks (hundreds–thousands of nodes).\n\n\np &lt;- data.frame(interactions)\np_attr &lt;- data.frame (node_attributes)\n\nn &lt;- graph_from_data_frame(p, directed = FALSE, vertices = p_attr)\n\nggraph(n, layout = \"fr\") + geom_edge_link(alpha = 0.3) +\n  geom_node_point(color = \"steelblue\") +\n  geom_node_text(aes(label = Gene_Id), repel = TRUE, max.overlaps = 1000, size = 2) + theme_void()\n\n\n\n\n\n\n\n\n\nggraph(n, layout = \"kk\") + geom_edge_link(alpha = 0.3) +\n  geom_node_point(color = \"steelblue\") +\n  geom_node_text(aes(label = Gene_Id), repel = TRUE, max.overlaps = 1000, size = 2) + theme_void()\n\n\n\n\n\n\n\n\nTASK: Explore TP53 in the network\nNow I will try to use the igraph function neighbors() to get a list of first-order interaction partners of TP53\n\n# neighbors() in igraph looks up vertices by the special attribute name. We have Gene_ID, not name. So here we assign all Gene_Ids to the atrribute name instead.\nV(n)$name &lt;- V(n)$Gene_Id\ntp &lt;- V(n)[name == \"TP53\"] #V (n) gives us the set of nodes of n, name == \"TP53\" is a filter on a vertex attribute called name. V(n)[ … ] subsets the vertices using that filter. Result: tp is a vertex sequence (an igraph object, just a selection of vertices that stays tied to a specific graph) containing the single vertex whose name is \"TP53\".\ntp # just to check\n\n+ 1/419 vertex, named, from 16930f4:\n[1] TP53\n\ntp_neighbors &lt;- neighbors(n, tp, mode = \"all\") # vertex sequence of neighbors\n\n# What it does:\n# neighbors() returns a vertex sequence of nodes directly connected to TP53.\n# mode = \"all\" is fine for undirected graphs (or use \"in\"/\"out\" for directed).\n\nlength(tp_neighbors) # number of first-order connections\n\n[1] 65\n\nstopifnot(length(tp_neighbors) == degree(n, v = tp, mode = \"all\")) # This is a line that ChatGPT wrote when I was asking for help. It is useful to think about it a litle. It simply stops R and tells it to throw an error if the length of tp_neighbors that we got, which is the number of first-order connecitons, does not equal the degree of the node tp (degree being the number of incident edges of tp, being the same as the number of neighbors in simple undirected graphs with no self-loops, etc), which is outputted by degree(n, v = tp, mode = \"all\").\n\n# TRUE only for TP53\nV(n)$is_tp53 &lt;- V(n)$name == \"TP53\"\n\n# \"no\" for everyone, then \"yes\" for neighbors of TP53\nV(n)$interacts_tp53 &lt;- rep(\"no\", vcount(n))\n\n#V(n)$interacts_tp53 &lt;- …\n#V(n) = the vertex sequence (all nodes) of graph n.\n\n#$interacts_tp53 creates/overwrites a vertex attribute called interacts_tp53.\n\n#A vertex attribute is just a vector with one value per node (length must equal vcount(n)), stored on the graph.\n\n#rep(\"no\", vcount(n)) -- vcount(n) returns the number of vertices (nodes) in graph n (419 in this case). rep(\"no\", 419) builds a character vector c(\"no\",\"no\",…,\"no\") of length 419.\n\n#So we are explicitly creating a value for every node: everyone starts as \"no\" (i.e., “does not interact with TP53”).\n\n#This is clearer/safer than assigning a single \"no\" and relying on R’s recycling; it guarantees exact length matching to vcount(n).\n\n#After this line, every node has interacts_tp53 == \"no\".\n\n#Then you flip the subset of TP53’s neighbors to \"yes\":\n\nV(n)[tp_neighbors]$interacts_tp53&lt;- \"yes\"\n\n# quick check\nsum(V(n)$is_tp53)              # expect 1\n\n[1] 1\n\ntable(V(n)$interacts_tp53)     # \"yes\" count should match length(tp_neighbors)\n\n\n no yes \n355  64 \n\nall(V(n)[tp_neighbors]$interacts_tp53 == \"yes\")   # should be TRUE\n\n[1] TRUE\n\n\nSo we have 65 first-order interactions with TP53 in this network.\n\nggraph(n, layout = \"fr\") +\n  geom_edge_link(alpha = 0.08) +\n  geom_node_point(aes(color = interacts_tp53, shape = is_tp53), size = 2.5) +\n  scale_color_manual(values = c(no = \"grey70\", yes = \"tomato\")) +\n  scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 15)) +\n  geom_node_text(aes(label = ifelse(is_tp53 | interacts_tp53 == \"yes\", name, \"\")),\n                 repel = TRUE, size = 2, max.overlaps = 1000) +\n  theme_void()\n\n\n\n\n\n\n\n\nNow, I will create a subnetwork consisting only of TP53 and its interaction partners, and label it with the corresponding gene names.\nOne way to do this is to use the delete_vertices() function to make a new graph, keeping only the nodes interacting with TP53. Another way to do it is by using induced_subgraph() and only keeping the nodes that are neighbours to TP53.\n\nkeep_vs &lt;- c(tp, tp_neighbors) # Concatenates all the neighbors and tp into a single vertex sequence. These are the ones we are keeping.\n\ntp53_ego &lt;- induced_subgraph(n, vids = keep_vs) #the induced_subgraph function takes n, and builds a new graph with only the vertices I decide to keep. These are denoted by the argument vids (stands for vertex identifiers). the object is called ego, because an ego-network (or ego-centric network) is the local subgraph centered on a focal actor (the ego) and their direct connections (alters).\n\n\nggraph(tp53_ego, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) + \n  geom_node_point(aes(color = ifelse(name == \"TP53\", \"TP53\", \"Partner\")), size = 3) +\n  scale_color_manual(values = c(TP53 = \"tomato\", Partner = \"steelblue\")) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) # label by 'name' (gene symbol) +\n\n\n\n\n\n\n\n  theme_void()\n\nList of 136\n $ line                            : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ rect                            : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ text                            :List of 11\n  ..$ family       : chr \"\"\n  ..$ face         : chr \"plain\"\n  ..$ colour       : chr \"black\"\n  ..$ size         : num 11\n  ..$ hjust        : num 0.5\n  ..$ vjust        : num 0.5\n  ..$ angle        : num 0\n  ..$ lineheight   : num 0.9\n  ..$ margin       : 'margin' num [1:4] 0points 0points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : logi FALSE\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ title                           : NULL\n $ aspect.ratio                    : NULL\n $ axis.title                      : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ axis.title.x                    : NULL\n $ axis.title.x.top                : NULL\n $ axis.title.x.bottom             : NULL\n $ axis.title.y                    : NULL\n $ axis.title.y.left               : NULL\n $ axis.title.y.right              : NULL\n $ axis.text                       : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ axis.text.x                     : NULL\n $ axis.text.x.top                 : NULL\n $ axis.text.x.bottom              : NULL\n $ axis.text.y                     : NULL\n $ axis.text.y.left                : NULL\n $ axis.text.y.right               : NULL\n $ axis.text.theta                 : NULL\n $ axis.text.r                     : NULL\n $ axis.ticks                      : NULL\n $ axis.ticks.x                    : NULL\n $ axis.ticks.x.top                : NULL\n $ axis.ticks.x.bottom             : NULL\n $ axis.ticks.y                    : NULL\n $ axis.ticks.y.left               : NULL\n $ axis.ticks.y.right              : NULL\n $ axis.ticks.theta                : NULL\n $ axis.ticks.r                    : NULL\n $ axis.minor.ticks.x.top          : NULL\n $ axis.minor.ticks.x.bottom       : NULL\n $ axis.minor.ticks.y.left         : NULL\n $ axis.minor.ticks.y.right        : NULL\n $ axis.minor.ticks.theta          : NULL\n $ axis.minor.ticks.r              : NULL\n $ axis.ticks.length               : 'simpleUnit' num 0points\n  ..- attr(*, \"unit\")= int 8\n $ axis.ticks.length.x             : NULL\n $ axis.ticks.length.x.top         : NULL\n $ axis.ticks.length.x.bottom      : NULL\n $ axis.ticks.length.y             : NULL\n $ axis.ticks.length.y.left        : NULL\n $ axis.ticks.length.y.right       : NULL\n $ axis.ticks.length.theta         : NULL\n $ axis.ticks.length.r             : NULL\n $ axis.minor.ticks.length         : 'simpleUnit' num 0points\n  ..- attr(*, \"unit\")= int 8\n $ axis.minor.ticks.length.x       : NULL\n $ axis.minor.ticks.length.x.top   : NULL\n $ axis.minor.ticks.length.x.bottom: NULL\n $ axis.minor.ticks.length.y       : NULL\n $ axis.minor.ticks.length.y.left  : NULL\n $ axis.minor.ticks.length.y.right : NULL\n $ axis.minor.ticks.length.theta   : NULL\n $ axis.minor.ticks.length.r       : NULL\n $ axis.line                       : NULL\n $ axis.line.x                     : NULL\n $ axis.line.x.top                 : NULL\n $ axis.line.x.bottom              : NULL\n $ axis.line.y                     : NULL\n $ axis.line.y.left                : NULL\n $ axis.line.y.right               : NULL\n $ axis.line.theta                 : NULL\n $ axis.line.r                     : NULL\n $ legend.background               : NULL\n $ legend.margin                   : NULL\n $ legend.spacing                  : NULL\n $ legend.spacing.x                : NULL\n $ legend.spacing.y                : NULL\n $ legend.key                      : NULL\n $ legend.key.size                 : 'simpleUnit' num 1.2lines\n  ..- attr(*, \"unit\")= int 3\n $ legend.key.height               : NULL\n $ legend.key.width                : NULL\n $ legend.key.spacing              : 'simpleUnit' num 5.5points\n  ..- attr(*, \"unit\")= int 8\n $ legend.key.spacing.x            : NULL\n $ legend.key.spacing.y            : NULL\n $ legend.frame                    : NULL\n $ legend.ticks                    : NULL\n $ legend.ticks.length             : 'rel' num 0.2\n $ legend.axis.line                : NULL\n $ legend.text                     :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : 'rel' num 0.8\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ legend.text.position            : NULL\n $ legend.title                    :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : num 0\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ legend.title.position           : NULL\n $ legend.position                 : chr \"right\"\n $ legend.position.inside          : NULL\n $ legend.direction                : NULL\n $ legend.byrow                    : NULL\n $ legend.justification            : NULL\n $ legend.justification.top        : NULL\n $ legend.justification.bottom     : NULL\n $ legend.justification.left       : NULL\n $ legend.justification.right      : NULL\n $ legend.justification.inside     : NULL\n $ legend.location                 : NULL\n $ legend.box                      : NULL\n $ legend.box.just                 : NULL\n $ legend.box.margin               : NULL\n $ legend.box.background           : NULL\n $ legend.box.spacing              : NULL\n  [list output truncated]\n - attr(*, \"class\")= chr [1:2] \"theme\" \"gg\"\n - attr(*, \"complete\")= logi TRUE\n - attr(*, \"validate\")= logi TRUE\n\n\nNow lets do it with delete_vertices()\n\nkeep_vs &lt;- c(tp, tp_neighbors) # so this is the same across both\ndrop_vs &lt;- V(n)[!(V(n) %in% keep_vs)] # but now there is this line, which makes it less straightforward compared to induced_subgraph(). this is basically everything in n, but not in keep_vs. \n\ntp53_ego2 &lt;- delete_vertices(n, drop_vs)\nggraph(tp53_ego2, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) + \n  geom_node_point(aes(color = ifelse(name == \"TP53\", \"TP53\", \"Partner\")), size = 3) +\n  scale_color_manual(values = c(TP53 = \"tomato\", Partner = \"steelblue\")) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) # label by 'name' (gene symbol) +\n\n\n\n\n\n\n\n  theme_void()\n\nList of 136\n $ line                            : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ rect                            : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ text                            :List of 11\n  ..$ family       : chr \"\"\n  ..$ face         : chr \"plain\"\n  ..$ colour       : chr \"black\"\n  ..$ size         : num 11\n  ..$ hjust        : num 0.5\n  ..$ vjust        : num 0.5\n  ..$ angle        : num 0\n  ..$ lineheight   : num 0.9\n  ..$ margin       : 'margin' num [1:4] 0points 0points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : logi FALSE\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ title                           : NULL\n $ aspect.ratio                    : NULL\n $ axis.title                      : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ axis.title.x                    : NULL\n $ axis.title.x.top                : NULL\n $ axis.title.x.bottom             : NULL\n $ axis.title.y                    : NULL\n $ axis.title.y.left               : NULL\n $ axis.title.y.right              : NULL\n $ axis.text                       : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ axis.text.x                     : NULL\n $ axis.text.x.top                 : NULL\n $ axis.text.x.bottom              : NULL\n $ axis.text.y                     : NULL\n $ axis.text.y.left                : NULL\n $ axis.text.y.right               : NULL\n $ axis.text.theta                 : NULL\n $ axis.text.r                     : NULL\n $ axis.ticks                      : NULL\n $ axis.ticks.x                    : NULL\n $ axis.ticks.x.top                : NULL\n $ axis.ticks.x.bottom             : NULL\n $ axis.ticks.y                    : NULL\n $ axis.ticks.y.left               : NULL\n $ axis.ticks.y.right              : NULL\n $ axis.ticks.theta                : NULL\n $ axis.ticks.r                    : NULL\n $ axis.minor.ticks.x.top          : NULL\n $ axis.minor.ticks.x.bottom       : NULL\n $ axis.minor.ticks.y.left         : NULL\n $ axis.minor.ticks.y.right        : NULL\n $ axis.minor.ticks.theta          : NULL\n $ axis.minor.ticks.r              : NULL\n $ axis.ticks.length               : 'simpleUnit' num 0points\n  ..- attr(*, \"unit\")= int 8\n $ axis.ticks.length.x             : NULL\n $ axis.ticks.length.x.top         : NULL\n $ axis.ticks.length.x.bottom      : NULL\n $ axis.ticks.length.y             : NULL\n $ axis.ticks.length.y.left        : NULL\n $ axis.ticks.length.y.right       : NULL\n $ axis.ticks.length.theta         : NULL\n $ axis.ticks.length.r             : NULL\n $ axis.minor.ticks.length         : 'simpleUnit' num 0points\n  ..- attr(*, \"unit\")= int 8\n $ axis.minor.ticks.length.x       : NULL\n $ axis.minor.ticks.length.x.top   : NULL\n $ axis.minor.ticks.length.x.bottom: NULL\n $ axis.minor.ticks.length.y       : NULL\n $ axis.minor.ticks.length.y.left  : NULL\n $ axis.minor.ticks.length.y.right : NULL\n $ axis.minor.ticks.length.theta   : NULL\n $ axis.minor.ticks.length.r       : NULL\n $ axis.line                       : NULL\n $ axis.line.x                     : NULL\n $ axis.line.x.top                 : NULL\n $ axis.line.x.bottom              : NULL\n $ axis.line.y                     : NULL\n $ axis.line.y.left                : NULL\n $ axis.line.y.right               : NULL\n $ axis.line.theta                 : NULL\n $ axis.line.r                     : NULL\n $ legend.background               : NULL\n $ legend.margin                   : NULL\n $ legend.spacing                  : NULL\n $ legend.spacing.x                : NULL\n $ legend.spacing.y                : NULL\n $ legend.key                      : NULL\n $ legend.key.size                 : 'simpleUnit' num 1.2lines\n  ..- attr(*, \"unit\")= int 3\n $ legend.key.height               : NULL\n $ legend.key.width                : NULL\n $ legend.key.spacing              : 'simpleUnit' num 5.5points\n  ..- attr(*, \"unit\")= int 8\n $ legend.key.spacing.x            : NULL\n $ legend.key.spacing.y            : NULL\n $ legend.frame                    : NULL\n $ legend.ticks                    : NULL\n $ legend.ticks.length             : 'rel' num 0.2\n $ legend.axis.line                : NULL\n $ legend.text                     :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : 'rel' num 0.8\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ legend.text.position            : NULL\n $ legend.title                    :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : num 0\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ legend.title.position           : NULL\n $ legend.position                 : chr \"right\"\n $ legend.position.inside          : NULL\n $ legend.direction                : NULL\n $ legend.byrow                    : NULL\n $ legend.justification            : NULL\n $ legend.justification.top        : NULL\n $ legend.justification.bottom     : NULL\n $ legend.justification.left       : NULL\n $ legend.justification.right      : NULL\n $ legend.justification.inside     : NULL\n $ legend.location                 : NULL\n $ legend.box                      : NULL\n $ legend.box.just                 : NULL\n $ legend.box.margin               : NULL\n $ legend.box.background           : NULL\n $ legend.box.spacing              : NULL\n  [list output truncated]\n - attr(*, \"class\")= chr [1:2] \"theme\" \"gg\"\n - attr(*, \"complete\")= logi TRUE\n - attr(*, \"validate\")= logi TRUE\n\n\nThere is actually another way to do that, which is perhaps more convenient than either. It uses the make_ego_graph() function.\n\ntp53_ego3 &lt;- make_ego_graph(n, order = 1, nodes = tp, mode = \"all\")[[1]] # we dont just use the function here because it outputs a list of GRAPHS, so then we use [[1]] to pull the tp-centered ego network out.\n\nggraph(tp53_ego3, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) + \n  geom_node_point(aes(color = ifelse(name == \"TP53\", \"TP53\", \"Partner\")), size = 3) +\n  scale_color_manual(values = c(TP53 = \"tomato\", Partner = \"steelblue\")) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) # label by 'name' (gene symbol) +\n\n\n\n\n\n\n\n  theme_void()\n\nList of 136\n $ line                            : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ rect                            : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ text                            :List of 11\n  ..$ family       : chr \"\"\n  ..$ face         : chr \"plain\"\n  ..$ colour       : chr \"black\"\n  ..$ size         : num 11\n  ..$ hjust        : num 0.5\n  ..$ vjust        : num 0.5\n  ..$ angle        : num 0\n  ..$ lineheight   : num 0.9\n  ..$ margin       : 'margin' num [1:4] 0points 0points 0points 0points\n  .. ..- attr(*, \"unit\")= int 8\n  ..$ debug        : logi FALSE\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ title                           : NULL\n $ aspect.ratio                    : NULL\n $ axis.title                      : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ axis.title.x                    : NULL\n $ axis.title.x.top                : NULL\n $ axis.title.x.bottom             : NULL\n $ axis.title.y                    : NULL\n $ axis.title.y.left               : NULL\n $ axis.title.y.right              : NULL\n $ axis.text                       : list()\n  ..- attr(*, \"class\")= chr [1:2] \"element_blank\" \"element\"\n $ axis.text.x                     : NULL\n $ axis.text.x.top                 : NULL\n $ axis.text.x.bottom              : NULL\n $ axis.text.y                     : NULL\n $ axis.text.y.left                : NULL\n $ axis.text.y.right               : NULL\n $ axis.text.theta                 : NULL\n $ axis.text.r                     : NULL\n $ axis.ticks                      : NULL\n $ axis.ticks.x                    : NULL\n $ axis.ticks.x.top                : NULL\n $ axis.ticks.x.bottom             : NULL\n $ axis.ticks.y                    : NULL\n $ axis.ticks.y.left               : NULL\n $ axis.ticks.y.right              : NULL\n $ axis.ticks.theta                : NULL\n $ axis.ticks.r                    : NULL\n $ axis.minor.ticks.x.top          : NULL\n $ axis.minor.ticks.x.bottom       : NULL\n $ axis.minor.ticks.y.left         : NULL\n $ axis.minor.ticks.y.right        : NULL\n $ axis.minor.ticks.theta          : NULL\n $ axis.minor.ticks.r              : NULL\n $ axis.ticks.length               : 'simpleUnit' num 0points\n  ..- attr(*, \"unit\")= int 8\n $ axis.ticks.length.x             : NULL\n $ axis.ticks.length.x.top         : NULL\n $ axis.ticks.length.x.bottom      : NULL\n $ axis.ticks.length.y             : NULL\n $ axis.ticks.length.y.left        : NULL\n $ axis.ticks.length.y.right       : NULL\n $ axis.ticks.length.theta         : NULL\n $ axis.ticks.length.r             : NULL\n $ axis.minor.ticks.length         : 'simpleUnit' num 0points\n  ..- attr(*, \"unit\")= int 8\n $ axis.minor.ticks.length.x       : NULL\n $ axis.minor.ticks.length.x.top   : NULL\n $ axis.minor.ticks.length.x.bottom: NULL\n $ axis.minor.ticks.length.y       : NULL\n $ axis.minor.ticks.length.y.left  : NULL\n $ axis.minor.ticks.length.y.right : NULL\n $ axis.minor.ticks.length.theta   : NULL\n $ axis.minor.ticks.length.r       : NULL\n $ axis.line                       : NULL\n $ axis.line.x                     : NULL\n $ axis.line.x.top                 : NULL\n $ axis.line.x.bottom              : NULL\n $ axis.line.y                     : NULL\n $ axis.line.y.left                : NULL\n $ axis.line.y.right               : NULL\n $ axis.line.theta                 : NULL\n $ axis.line.r                     : NULL\n $ legend.background               : NULL\n $ legend.margin                   : NULL\n $ legend.spacing                  : NULL\n $ legend.spacing.x                : NULL\n $ legend.spacing.y                : NULL\n $ legend.key                      : NULL\n $ legend.key.size                 : 'simpleUnit' num 1.2lines\n  ..- attr(*, \"unit\")= int 3\n $ legend.key.height               : NULL\n $ legend.key.width                : NULL\n $ legend.key.spacing              : 'simpleUnit' num 5.5points\n  ..- attr(*, \"unit\")= int 8\n $ legend.key.spacing.x            : NULL\n $ legend.key.spacing.y            : NULL\n $ legend.frame                    : NULL\n $ legend.ticks                    : NULL\n $ legend.ticks.length             : 'rel' num 0.2\n $ legend.axis.line                : NULL\n $ legend.text                     :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : 'rel' num 0.8\n  ..$ hjust        : NULL\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ legend.text.position            : NULL\n $ legend.title                    :List of 11\n  ..$ family       : NULL\n  ..$ face         : NULL\n  ..$ colour       : NULL\n  ..$ size         : NULL\n  ..$ hjust        : num 0\n  ..$ vjust        : NULL\n  ..$ angle        : NULL\n  ..$ lineheight   : NULL\n  ..$ margin       : NULL\n  ..$ debug        : NULL\n  ..$ inherit.blank: logi TRUE\n  ..- attr(*, \"class\")= chr [1:2] \"element_text\" \"element\"\n $ legend.title.position           : NULL\n $ legend.position                 : chr \"right\"\n $ legend.position.inside          : NULL\n $ legend.direction                : NULL\n $ legend.byrow                    : NULL\n $ legend.justification            : NULL\n $ legend.justification.top        : NULL\n $ legend.justification.bottom     : NULL\n $ legend.justification.left       : NULL\n $ legend.justification.right      : NULL\n $ legend.justification.inside     : NULL\n $ legend.location                 : NULL\n $ legend.box                      : NULL\n $ legend.box.just                 : NULL\n $ legend.box.margin               : NULL\n $ legend.box.background           : NULL\n $ legend.box.spacing              : NULL\n  [list output truncated]\n - attr(*, \"class\")= chr [1:2] \"theme\" \"gg\"\n - attr(*, \"complete\")= logi TRUE\n - attr(*, \"validate\")= logi TRUE"
  },
  {
    "objectID": "nbs/week2-louvian.html#part-iii.-network-statistics",
    "href": "nbs/week2-louvian.html#part-iii.-network-statistics",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Part III. Network statistics",
    "text": "Part III. Network statistics\nNow I will calculate the following statistics for the full network:\n\nAverage node degree (average number of incident edges across the network)\nAverage clustering coefficient (also known as transitivity)\nConcept:\nClustering coefficient = tendency of neighbors of a node to also be connected (i.e. “triangles”).\n\nLocal clustering coefficient: how clustered around a single node.\nGlobal clustering coefficient: average across all nodes (or ratio of closed triplets to all triplets).\n\nNetwork diameter\nConcept:\nThe longest shortest path between any two nodes in the graph.\nIn other words, how far apart the most distant nodes are (measured in steps).\n\n\ndeg &lt;- degree(n, mode = \"all\") # degree of every vertex\nmean(deg) # average degree\n\n[1] 5.198091\n\ntransitivity(n, type = \"average\") # mean of local clustering coefficients over all nodes.(Skip nodes with degree &lt; 2, since clustering coefficient is undefined there.))\n\n[1] 0.1609234\n\ndiameter(n, directed = FALSE)  # since the graph is undirected\n\n[1] 4\n\n\nNow we will make a plot of the distribution of node degrees.\n\ndeg &lt;- degree(n)\n\nhist(deg, # the data vector (degrees for all nodes).\n     breaks = 50, # Divide the x-axis (degree values) into 50 bins. More bins → more detail; fewer bins → smoother but less detail.\n     main   = \"Node Degree Distribution\", #The title of the plot\n     xlab   = \"Degree\", #Label of the x-axis. Here it represents the degree value (number of neighbors).\n     ylab   = \"Frequency\", # Label of the y-axis. It shows how many nodes fall into each degree bin.\n     col    = \"lightblue\", #Fills the bars of the histogram with light blue color.\n     border = \"white\" #Sets the outline color of the bars to white, making the bars visually cleaner.\n     )\ntp_deg &lt;- degree(n, v = V(n)[name == \"TP53\"])\nabline(v = tp_deg, col = \"red\", lwd = 2)  # adds vertical line at TP53's degree. lwd denotes the line width.\n\n\n\n\n\n\n\n\nSo here we can see that the degree of TP53 is literally off the chart. That clearly means it’s an important protein in this network. But that’s because the whole dataset consists of proteins that interact with the transcription factor TP53 (also known as P53).\nNow I will calculate the node-wise clustering coefficient. This is done with the transitivity() function, setting the variable type = “local”. And plot a histogram, like before.\n\nclust &lt;- transitivity(n, type = \"local\")\n\nhist(clust,\n     breaks = 50,\n     main   = \"Local Clustering Coefficient Distribution\",\n     xlab   = \"Clustering Coefficient\",\n     ylab   = \"Frequency\",\n     col    = \"lightgreen\", border = \"white\")\ntp_clust &lt;- clust[which(V(n)$name == \"TP53\")]\nabline(v = tp_clust, col = \"red\", lwd = 2)\n\n\n\n\n\n\n\ntp_clust\n\n      TP53 \n0.01177675 \n\n\nSo, perhaps unexpectedly, we can see that TP53 has a clustering coefficient of 0.012. That means that TP53 is important, as it connects to proteins that themselves are not interconnected, influencing otherwise separate groups."
  },
  {
    "objectID": "nbs/week2-louvian.html#part-iv.-network-clustering",
    "href": "nbs/week2-louvian.html#part-iv.-network-clustering",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Part IV. Network clustering",
    "text": "Part IV. Network clustering"
  },
  {
    "objectID": "nbs/week2-louvian.html#louvain-clustering",
    "href": "nbs/week2-louvian.html#louvain-clustering",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Louvain clustering",
    "text": "Louvain clustering\n\nConcept\n\nGoal: partition the network into subclusters (communities) such that nodes are densely connected within clusters and more sparsely connected between clusters.\nAlgorithm: Louvain clustering maximizes modularity (a score of how well the network splits into modules). This makes the graph much much more easily comprehensible visually, as you will see.\nResolution parameter: controls the granularity.\n\nLow resolution → fewer, larger clusters.\nHigh resolution → more, smaller clusters.\nThis is adjusted manually to see what best reveals structure.\n\n\n\n\nResolution: too low → one or two giant clusters; too high → many tiny clusters.\nCluster numbers: They are arbitrary (cluster #2 doesn’t mean “second most important”). A good idea is to inspect the size with table(membership_vec).\nDisconnected components: Diameter and clustering coefficient are only meaningful if the cluster has at least a few nodes.\n\n\n# Running Louvain clustering\ncl &lt;- cluster_louvain(n, resolution = 2) #We will start with resolution of 1.\n\n# Each vertex gets a cluster membership\nmembership_vec &lt;- membership(cl)\n# ChatGPT explanation:\n# membership(): extracts the cluster ID for each vertex from the community object cl.\n# Result: membership_vec is an integer vector of length = number of nodes in your graph.\n# Example:\n# [1] 1 1 2 2 2 3 1 3 ...\n# Each entry corresponds to one vertex (in the same order as V(n)), and the number is the cluster label.\n# So if membership_vec[10] = 2, that means vertex 10 belongs to cluster 2.\n# Cluster labels are arbitrary integers (1, 2, 3, …). They don’t imply ranking or importance, just grouping.\n\n# How many clusters?\nlength(unique(membership_vec))\n\n[1] 23\n\ntable(membership_vec)   # size of each cluster\n\nmembership_vec\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \n20 26 15 20 26 23 21  6 18 23 13 26  5 22 23 13 13 25 12 27 14 21  7 \n\nggraph(n, layout = \"fr\") +\n  geom_edge_link(alpha = 0.05) +\n  geom_node_point(aes(color = factor(membership_vec)), size = 2) +\n  geom_node_text(aes(label = ifelse(name == \"TP53\", name, \"\")),\n                 repel = TRUE, color = \"black\", size = 3) +\n  theme_void()\n\n\n\n\n\n\n\n\nAnd finally, we can now extract a sub-network from cluster two and calculate the statistics, just like before:\n\nsub_nodes &lt;- V(n)[membership_vec == 2]\ncluster2 &lt;- induced_subgraph(n, vids = sub_nodes)\n# Average degree\ndeg2 &lt;- degree(cluster2)\nmean(deg2)\n\n[1] 3.846154\n\nhist(deg2, # the data vector (degrees for all nodes).\n     breaks = 50, # Divide the x-axis (degree values) into 50 bins. More bins → more detail; fewer bins → smoother but less detail.\n     main   = \"Node Degree Distribution of Cluster 2\", #The title of the plot\n     xlab   = \"Degree\", #Label of the x-axis. Here it represents the degree value (number of neighbors).\n     ylab   = \"Frequency\", # Label of the y-axis. It shows how many nodes fall into each degree bin.\n     col    = \"lightblue\", #Fills the bars of the histogram with light blue color.\n     border = \"white\" #Sets the outline color of the bars to white, making the bars visually cleaner.\n     )\n\n\n\n\n\n\n\n# Average clustering coefficient\ntransitivity(cluster2, type = \"average\")\n\n[1] 0.4354145\n\nsub_clust &lt;- transitivity(cluster2, type = \"local\")\n\nhist(sub_clust,\n     breaks = 50,\n     main   = \"Local Clustering Coefficient Distribution of Cluster 2\",\n     xlab   = \"Clustering Coefficient\",\n     ylab   = \"Frequency\",\n     col    = \"lightgreen\", border = \"white\")\n\n\n\n\n\n\n\n# Diameter\ndiameter(cluster2, directed = FALSE)\n\n[1] 5\n\nggraph(cluster2, layout = \"fr\") +\n  geom_edge_link(alpha = 0.1) +\n  geom_node_point(color = \"steelblue\", size = 3) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 2) +\n  theme_void()\n\n\n\n\n\n\n\n\nThat’s all!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Systems Biology",
    "section": "",
    "text": "This is my personal site for the course Introduction to Systems Biology (BSc/MSc).\nI’m collecting my exercise solutions here. The code isn’t meant to be perfect—it’s a working record of my learning process, to consolidate material and maybe help others following along.\n\n\n\nIn this course, we cover three arcs: foundations of network analysis, core systems biology workflows, and applied biomedical use-cases.\n\n\n\n\nWhy networks for biological problems\n\nBasics of network analysis\n\nTopology, key metrics, community detection\n\n\n\n\n\nFunctional regulation components\n\nVisualizing regulatory networks\n\nTranscriptomics on networks\n\nTime-series + networks → regulatory modes\n\n\n\n\n\nMulti-species PPI → inferred human interactome\n\nVirtual pulldowns & relevance-scored networks\n\nProtein isoforms in systems biology\n\nDisease-focused molecular network analysis\n\n\n\n\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n\n\nNetwork topology\n\nClustering\n\nAdvanced Visualization\n\n\n\n\n\n\n\nSep 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBasics\n\nVisualization\n\n\n\nLearn the basics of network visualization with igraph for systems biology.\n\n\n\nSep 4, 2025\n\n\n\n\n\n\nNo matching items\nQuarto is pretty nice."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Introduction to Systems Biology",
    "section": "",
    "text": "This is my personal site for the course Introduction to Systems Biology (BSc/MSc).\nI’m collecting my exercise solutions here. The code isn’t meant to be perfect—it’s a working record of my learning process, to consolidate material and maybe help others following along."
  },
  {
    "objectID": "index.html#course-outline",
    "href": "index.html#course-outline",
    "title": "Introduction to Systems Biology",
    "section": "",
    "text": "In this course, we cover three arcs: foundations of network analysis, core systems biology workflows, and applied biomedical use-cases.\n\n\n\n\nWhy networks for biological problems\n\nBasics of network analysis\n\nTopology, key metrics, community detection\n\n\n\n\n\nFunctional regulation components\n\nVisualizing regulatory networks\n\nTranscriptomics on networks\n\nTime-series + networks → regulatory modes\n\n\n\n\n\nMulti-species PPI → inferred human interactome\n\nVirtual pulldowns & relevance-scored networks\n\nProtein isoforms in systems biology\n\nDisease-focused molecular network analysis"
  },
  {
    "objectID": "index.html#all-notebooks",
    "href": "index.html#all-notebooks",
    "title": "Introduction to Systems Biology",
    "section": "",
    "text": "Network topology\n\nClustering\n\nAdvanced Visualization\n\n\n\n\n\n\n\nSep 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBasics\n\nVisualization\n\n\n\nLearn the basics of network visualization with igraph for systems biology.\n\n\n\nSep 4, 2025\n\n\n\n\n\n\nNo matching items"
  }
]