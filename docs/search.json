[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is my personal site for the course Introduction to Systems Biology (BSc/MSc). I’m collecting my exercise solutions here. The code isn’t meant to be perfect—it’s a working record of my learning process, to consolidate material and maybe help others following along."
  },
  {
    "objectID": "nbs/week1-igraph.html",
    "href": "nbs/week1-igraph.html",
    "title": "Week 1: Introduction to igraph",
    "section": "",
    "text": "TASK: Make a simple network in igraph\n\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\nlibrary(ggraph)\n\nLoading required package: ggplot2\n\nlibrary(tidygraph)\n\n\nAttaching package: 'tidygraph'\n\n\nThe following object is masked from 'package:igraph':\n\n    groups\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\n\nhemoglobin &lt;- data.frame(from = c(\"ALPHA_GLOBIN\", \"ALPHA_GLOBIN\", \"BETA_GLOBIN\"), to = c(\"ALPHA_GLOBIN\", \"BETA_GLOBIN\", \"BETA_GLOBIN\"))\ng &lt;- graph_from_data_frame(hemoglobin, directed = FALSE, vertices = NULL)\nplot(g)\n\n\n\n\n\n\n\n\n\nMake sure you understand what the NODES (the circles) and the EDGES (the lines) represent: what is the BIOLOGICAL interpretation of the network?\nIn this protein-protein interaction graph, each node represents a protein and each edge represents interaction between them.\n\nTASK: create data frame for the polymerase sub-unit interactions and add attributes to igraph object:\n\npolymerase_subunit &lt;- data.frame(from = c(\"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD3_HUMAN\"), to = c(\"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"DPOD4_HUMAN\"))\nps_attr &lt;- data.frame(name = c(\"DPOD1_HUMAN\", \"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\"), GeneID = c(\"PolD1\", \"PolD2\", \"PolD3\", \"PolD4\"), Catalytic = c(\"yes\", \"no\", \"no\", \"no\"), Description = c(\n    \"DNA polymerase delta catalytic subunit\",\n    \"DNA polymerase delta subunit 2\",\n    \"DNA polymerase delta subunit 3\",\n    \"DNA polymerase delta subunit 4\"\n), AA = c(1009, 469, 466, 107))\np &lt;- graph_from_data_frame(polymerase_subunit, directed = FALSE, vertices = ps_attr)\nplot(p)\n\n\n\n\n\n\n\nV(p)$Description\n\n[1] \"DNA polymerase delta catalytic subunit\"\n[2] \"DNA polymerase delta subunit 2\"        \n[3] \"DNA polymerase delta subunit 3\"        \n[4] \"DNA polymerase delta subunit 4\"        \n\n\nTASK - use the node annotations for customizing visualization\n\nggraph(p) +\n    geom_edge_link() +\n    geom_node_point()\n\nUsing \"stress\" as default layout\n\n\n\n\n\n\n\n\n\nWay to visualize protein-protein interactions? Definetly not – not a lot of information is represented.\n\nggraph(p) + geom_edge_link() + geom_node_point(aes(colour = Catalytic, size = AA)) + geom_node_text(aes(label = name), repel = TRUE)\n\nUsing \"stress\" as default layout\n\n\n\n\n\n\n\n\n\n\nExtended Pol δ network\nFor the final part of the exercise we’ll be working with set of experimental data centered around the Pol δ complex. Later in the course we will learn a lot of details about how such experimental data is generated, what strengths and weaknesses the different methods have, and how we can address the noise in the data.\nFor now it sufficient to note the following:\n\nThe experiment has detected proteins that physically interacts with the PolD1-PolD4 complex we have just worked with.\nBoth stable and transient interactions have been identified.\nThe experiment shows some of the most likely interactions - additional experiments may find more.\nThe data may contain false positive (proteins indicated to interact, while that is not true under real biological conditions).\n\n\npoldelta_extented_interactions &lt;- data.frame(from = c(\"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD1_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD3_HUMAN\", \"DPOD3_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"DPOD4_HUMAN\", \"DPOD4_HUMAN\", \"DPOD4_HUMAN\", \"PRI1_HUMAN\", \"WRIP1_HUMAN\"), to = c(\"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"S7A6O_HUMAN\", \"TREX2_HUMAN\", \"DNA2L_HUMAN\", \"PRI1_HUMAN\", \"PRI2_HUMAN\", \"WRIP1_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\", \"PDIP2_HUMAN\", \"BACD1_HUMAN\", \"WRIP1_HUMAN\", \"DNA2L_HUMAN\", \"PRI1_HUMAN\", \"PRI2_HUMAN\", \"DPOD4_HUMAN\", \"DNA2L_HUMAN\", \"PRI1_HUMAN\", \"PRI2_HUMAN\", \"DNA2L_HUMAN\", \"PRI1_HUMAN\", \"PRI2_HUMAN\", \"WRIP1_HUMAN\", \"PRI2_HUMAN\", \"WRIP1_HUMAN\"), confidence = c(1.00, 1.00, 1.00, 0.18, 1.00, 1.00, 1.00, 1.00, 0.52, 1.00, 1.00, 1.00, 1.00, 0.54, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00, 0.57, 1.00, 0.65))\ne &lt;- graph_from_data_frame(poldelta_extented_interactions, directed = FALSE, vertices = NULL)\n\n\nggraph(e, layout = \"kk\") + geom_edge_link() + geom_node_point() + geom_node_label(aes(label = name), repel = TRUE)\n\n\n\n\n\n\n\n\nLinear is not a suitable layout, because it loses out on clustering of interactions.\nTASK - visualize the Node attributes\n\nNode label - use GeneID\nNode color - color based on “Role in replication” (invent your own coloring scheme)\nNode shape - pick two shapes to represent whether the protein is known to bind to DNA\nThe graph design was done with ChatGPT this time.\n\n\nextended_attr &lt;- data.frame(\n    name = c(\n        \"DPOD1_HUMAN\", \"DPOD2_HUMAN\", \"DPOD3_HUMAN\", \"DPOD4_HUMAN\",\n        \"BACD1_HUMAN\", \"DNA2L_HUMAN\", \"PDIP2_HUMAN\", \"PRI1_HUMAN\",\n        \"PRI2_HUMAN\", \"S7A6O_HUMAN\", \"TREX2_HUMAN\", \"WRIP1_HUMAN\"\n    ),\n    GeneID = c(\n        \"POLD1\", \"POLD2\", \"POLD3\", \"POLD4\",\n        \"PDIP1\", \"DNA2\", \"POLDIP2\", \"PRIM1\",\n        \"PRIM2\", \"SLC7A6OS\", \"TREX2\", \"WRNIP1\"\n    ),\n    Role_in_replication = c(\n        \"Polymerase\", \"Polymerase\", \"Polymerase\", \"Polymerase\",\n        \"Uncertain\", \"Helicase\", \"Uncertain\", \"Primase\",\n        \"Primase\", \"Uncertain\", \"DNA repair\", \"DNA repair\"\n    ),\n    Cellular_component = c(\n        \"Nucleus\", \"Nucleus\", \"Nucleus\", \"Nucleus\",\n        \"Nucleus\", \"Nucleus; Mitochondrion\", \"Nucleus\", \"Nucleus (Nucleoplasm)\",\n        \"Nucleus (Nucleoplasm)\", \"Nucleus\", \"Nucleus\", \"Nucleus\"\n    ),\n    DNA_Binding = c(\n        \"+\", \"+\", \"-\", \"-\",\n        \"-\", \"+\", \"+\", \"+\",\n        \"+\", \"-\", \"+\", \"-\"\n    ),\n    Description = c(\n        \"DNA polymerase delta catalytic subunit\",\n        \"DNA polymerase delta subunit 2\",\n        \"DNA polymerase delta subunit 3\",\n        \"DNA polymerase delta subunit 4\",\n        \"Polymerase delta-interacting protein 1\",\n        \"DNA replication helicase/nuclease 2\",\n        \"Polymerase delta-interacting protein 2\",\n        \"DNA primase small subunit\",\n        \"DNA primase large subunit\",\n        \"Probable RNA Pol II localization factor\",\n        \"3′→5′ exonuclease, DNA repair\",\n        \"Werner helicase-interacting protein 1\"\n    )\n)\n\ne &lt;- graph_from_data_frame(poldelta_extented_interactions, directed = FALSE, vertices = extended_attr)\n\nggraph(e, layout = \"kk\") +\n\n    geom_edge_link() +\n\n    # NODES\n    geom_node_point(\n        aes(\n            colour = Role_in_replication,\n            shape  = DNA_Binding\n        ),\n        size = 6\n    ) +\n    geom_node_label(aes(label = GeneID), repel = TRUE, box.padding = 0.4) +\n\n    # Node color scheme\n    scale_colour_manual(values = c(\n        \"Polymerase\" = \"steelblue\",\n        \"Primase\"    = \"forestgreen\",\n        \"Helicase\"   = \"orange\",\n        \"DNA repair\" = \"purple\",\n        \"Uncertain\"  = \"gray40\"\n    ), na.translate = FALSE) +\n\n    # Node shape scheme (+ binds DNA, – does not)\n    scale_shape_manual(values = c(\"+\" = 16, \"-\" = 15), na.translate = FALSE) +\n\n    # Optional: hide edge legends\n    guides(edge_colour = \"none\", edge_alpha = \"none\", edge_width = \"none\") +\n\n    theme_void()\n\n\n\n\n\n\n\n\nDoes it make sense that some of the proteins are not annotated to bind DNA yet are supposed to have a role in DNA replication? (For example DPOD3_HUMAN and DPOD4_HUMAN)\n\nYes, it does as some of these proteins are subunits of complexes that do bind DNA.\n“Catalytic vs accessory subunits:\n\nPOLD1 (DPOD1_HUMAN) is the catalytic subunit of DNA polymerase δ, with DNA polymerase and exonuclease domains — it binds DNA directly.\nPOLD2, POLD3, POLD4 are accessory subunits. They don’t themselves have DNA-binding motifs but they stabilize the catalytic subunit, anchor PCNA, or mediate interactions with other replication/repair factors.”\n\nEach edge in the Pol δ network represents a protein-protein interaction determined experimentally. A number of different pieces of information could potentially be associated with each interaction:\n\nExperimental method used.\nWhether the interaction is stable or transient.\nHow much experimental support is there for the interactions (e.g. a single experiment, 3 experiments or 100+ experiments).\n\n\nYou may consider the following interpretation of the score:\n\n0.0 - 0.3 : poor experimental support\n0.3 - 0.9 : “good enough” experimental support\n0.9 - 1.0 : excellent experimental support\n\nTASK - import and visualize network\n\nMake an igraph object with the interactions, edge attributes, and node attributes\nVisualize the network with ggraph, adding some formatting of the edges continuously by the confidence score (color, width, or transparency are good options)\nMake a discrete vector based on the three categories above, and add reload the igraph object. Make three different colors, widths, line types, or whatever else you can come up with to make a visually pleasing and informative visualization.\n\n\nggraph(e, layout = \"kk\") +\n    geom_edge_link(\n        aes(\n            edge_colour = confidence,\n            edge_alpha = confidence,\n            edge_width = confidence\n        )\n    ) +\n    scale_edge_colour_gradientn(\n        colours = c(\"plum1\", \"mediumpurple3\", \"purple4\"),\n        values  = c(0, 0.3, 0.9, 1),\n        name    = \"Confidence\" # name for the edge colorbar\n    ) +\n    guides(edge_colour = guide_edge_colourbar(\n        title  = \"Confidence\",\n        ticks  = TRUE,\n        breaks = c(0.15, 0.6, 0.95),\n        labels = c(\"0.0–0.3 poor\", \"0.3–0.9 good\", \"0.9–1.0 excellent\")\n    )) +\n    scale_edge_alpha(range = c(0.2, 1)) +\n    scale_edge_width(range = c(0.3, 1.5)) +\n\n    # NODES\n    geom_node_point(aes(colour = Role_in_replication, shape = DNA_Binding), size = 6) +\n    geom_node_label(aes(label = GeneID), repel = TRUE, box.padding = 0.4) +\n    scale_colour_manual(values = c(\n        \"Polymerase\" = \"steelblue\",\n        \"Primase\"    = \"forestgreen\",\n        \"Helicase\"   = \"orange\",\n        \"DNA repair\" = \"purple\",\n        \"Uncertain\"  = \"gray40\"\n    ), na.translate = FALSE) +\n    scale_shape_manual(values = c(\"+\" = 16, \"-\" = 15), na.translate = FALSE) +\n    theme_void()\n\nWarning in guide_colourbar(..., available_aes = available_aes): Arguments in `...` must be used.\n✖ Problematic arguments:\n• breaks = c(0.15, 0.6, 0.95)\n• labels = c(\"0.0–0.3 poor\", \"0.3–0.9 good\", \"0.9–1.0 excellent\")\nℹ Did you misspell an argument name?\n\n\n\n\n\n\n\n\n\nWhich do you prefer - continuous or discrete visualization of line colors? I prefer continuous\nFINAL QUESTION - Re-evaluate the three “uncertain” proteins (BACD1_HUMAN, PDIP2_HUMAN, S7A6O_HUMAN):\nConsider the following points and make a conclusion based on the combined evidence on which of the three proteins are likely to be true interaction partners:\n\nThe proteins they are interacting with.\nThe experimental support for the interactions.\nAny biological information (any hints, basically) you may have picked up from skimming through the UniProt pages for each of the three proteins.\n\nBased on the experimental evidence, BACD1_HUMAN, PDIP2_HUMAN are true interaction partners. They both also interact with DPOD2_HUMAN, which is clearly involved. BACD1_HUMAN seems to be a co-factor for DPOD2_HUMAN. But S7A6O_HUMAN does not seem to be involved as the experimental support is very weak."
  },
  {
    "objectID": "nbs/week2-louvian.html",
    "href": "nbs/week2-louvian.html",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "",
    "text": "Today we will get a bit more advanced with our use of igraph!\nIn this exercise we will use a subset of the human interaction dataset by Rual et al. (Nature.2005 Oct 20;437(7062):1173-8). The data consists of an interaction data frame (without edge annotations) and a node annotation data frame with gene names."
  },
  {
    "objectID": "nbs/week2-louvian.html#part-i.-getting-started",
    "href": "nbs/week2-louvian.html#part-i.-getting-started",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Part I. Getting started",
    "text": "Part I. Getting started\n\n# Load packages\nlibrary(igraph); library(ggraph); library(tidygraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n\nLoading required package: ggplot2\n\n\n\nAttaching package: 'tidygraph'\n\n\nThe following object is masked from 'package:igraph':\n\n    groups\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\n\nload(\"./data/exercise2.Rdata\")\n\nThis network consists of 1089 interactions observed between 419 human proteins, and is a small subset of a larger human interaction dataset. This subset consists of proteins that interact with the transcription factor TP53 (also known as P53).\nTake a moment to read about the function of TP53 by looking it up in UniProt:\n\nhttp://www.uniprot.org/uniprot/P53_HUMAN\n\nIn short, the human TP53 gene encodes cellular tumor antigen p53, a crucial transcription factor that acts as a central tumor suppressor and guardian of genomic integrity. In response to various cellular stresses such as DNA damage, oncogene activation, hypoxia, or oxidative stress, p53 becomes stabilized and activated through post-translational modifications that prevent its normal rapid degradation. Once active, it binds specific DNA response elements to regulate a large network of target genes involved in cell cycle arrest (e.g. via p21/CDKN1A), DNA repair (e.g. GADD45), senescence, and apoptosis (e.g. BAX, PUMA, NOXA). This coordinated response allows cells either to pause and repair their DNA or, if damage is irreparable, to undergo programmed cell death, thus preventing the propagation of potentially oncogenic mutations. Because of this role, p53 is often called the “guardian of the genome.” Inactivation or mutation of TP53—commonly seen in over half of human cancers—disrupts these protective pathways, enabling unchecked cell proliferation and genomic instability, which significantly contributes to tumorigenesis."
  },
  {
    "objectID": "nbs/week2-louvian.html#part-ii.-network-layout-and-selecting-nodes",
    "href": "nbs/week2-louvian.html#part-ii.-network-layout-and-selecting-nodes",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Part II. Network layout and Selecting nodes",
    "text": "Part II. Network layout and Selecting nodes\nTASK: Explore network layouts\nSo, now here I show two different layouts for the same network. The first is fr (Fruchterman–Reingold layout), and the second is kk (Kamada–Kawai layout) – ggraph(n, layout = “fr”) and ggraph(n, layout = “kk”). Both are quit messy – hairballs. Really difficult to see anything meaningful without analysis. But either way, with kk we can sort of see some hubs in the center, but it does look a bit more messy, while with fr, the plot looks more spaced out, with slightly more comprehensible peripheral nodes. In this case, I prefer fr.\nHere is a little information from ChatGPT about both layouts:\nName: Kamada–Kawai algorithm (kk)\nHow it works:\n\nTreats the graph like a spring system.\nEach pair of nodes has an “ideal” distance based on their graph-theoretic shortest path distance.\nThe algorithm minimizes the difference between ideal and actual distances.\n\nEffect:\n\nProduces fairly symmetrical and uniformly spaced graphs.\nWorks especially well for smaller networks (tens–hundreds of nodes).\n\nName: Fruchterman–Reingold algorithm (fr)\nHow it works:\n\nAlso uses a force-directed model:\n\nconnected nodes attract each other\nall nodes repel each other like charged particles\n\nThe system iteratively simulates forces until it reaches equilibrium.\n\nEffect:\n\nTends to produce clustered, organic “clouds”.\nWorks well for larger networks (hundreds–thousands of nodes).\n\n\np &lt;- data.frame(interactions)\np_attr &lt;- data.frame (node_attributes)\n\nn &lt;- graph_from_data_frame(p, directed = FALSE, vertices = p_attr)\n\nggraph(n, layout = \"fr\") + geom_edge_link(alpha = 0.3) +\n  geom_node_point(color = \"steelblue\") +\n  geom_node_text(aes(label = Gene_Id), repel = TRUE, max.overlaps = 1000, size = 2) + theme_void()\n\n\n\n\n\n\n\n\n\nggraph(n, layout = \"kk\") + geom_edge_link(alpha = 0.3) +\n  geom_node_point(color = \"steelblue\") +\n  geom_node_text(aes(label = Gene_Id), repel = TRUE, max.overlaps = 1000, size = 2) + theme_void()\n\n\n\n\n\n\n\n\nTASK: Explore TP53 in the network\nNow I will try to use the igraph function neighbors() to get a list of first-order interaction partners of TP53\n\n# neighbors() in igraph looks up vertices by the special attribute name. We have Gene_ID, not name. So here we assign all Gene_Ids to the atrribute name instead.\nV(n)$name &lt;- V(n)$Gene_Id\ntp &lt;- V(n)[name == \"TP53\"] #V (n) gives us the set of nodes of n, name == \"TP53\" is a filter on a vertex attribute called name. V(n)[ … ] subsets the vertices using that filter. Result: tp is a vertex sequence (an igraph object, just a selection of vertices that stays tied to a specific graph) containing the single vertex whose name is \"TP53\".\ntp # just to check\n\n+ 1/419 vertex, named, from 0583a55:\n[1] TP53\n\ntp_neighbors &lt;- neighbors(n, tp, mode = \"all\") # vertex sequence of neighbors\n\n# What it does:\n# neighbors() returns a vertex sequence of nodes directly connected to TP53.\n# mode = \"all\" is fine for undirected graphs (or use \"in\"/\"out\" for directed).\n\nlength(tp_neighbors) # number of first-order connections\n\n[1] 65\n\nstopifnot(length(tp_neighbors) == degree(n, v = tp, mode = \"all\")) # This is a line that ChatGPT wrote when I was asking for help. It is useful to think about it a litle. It simply stops R and tells it to throw an error if the length of tp_neighbors that we got, which is the number of first-order connecitons, does not equal the degree of the node tp (degree being the number of incident edges of tp, being the same as the number of neighbors in simple undirected graphs with no self-loops, etc), which is outputted by degree(n, v = tp, mode = \"all\").\n\n# TRUE only for TP53\nV(n)$is_tp53 &lt;- V(n)$name == \"TP53\"\n\n# \"no\" for everyone, then \"yes\" for neighbors of TP53\nV(n)$interacts_tp53 &lt;- rep(\"no\", vcount(n))\n\n#V(n)$interacts_tp53 &lt;- …\n#V(n) = the vertex sequence (all nodes) of graph n.\n\n#$interacts_tp53 creates/overwrites a vertex attribute called interacts_tp53.\n\n#A vertex attribute is just a vector with one value per node (length must equal vcount(n)), stored on the graph.\n\n#rep(\"no\", vcount(n)) -- vcount(n) returns the number of vertices (nodes) in graph n (419 in this case). rep(\"no\", 419) builds a character vector c(\"no\",\"no\",…,\"no\") of length 419.\n\n#So we are explicitly creating a value for every node: everyone starts as \"no\" (i.e., “does not interact with TP53”).\n\n#This is clearer/safer than assigning a single \"no\" and relying on R’s recycling; it guarantees exact length matching to vcount(n).\n\n#After this line, every node has interacts_tp53 == \"no\".\n\n#Then you flip the subset of TP53’s neighbors to \"yes\":\n\nV(n)[tp_neighbors]$interacts_tp53&lt;- \"yes\"\n\n# quick check\nsum(V(n)$is_tp53)              # expect 1\n\n[1] 1\n\ntable(V(n)$interacts_tp53)     # \"yes\" count should match length(tp_neighbors)\n\n\n no yes \n355  64 \n\nall(V(n)[tp_neighbors]$interacts_tp53 == \"yes\")   # should be TRUE\n\n[1] TRUE\n\n\nSo we have 65 first-order interactions with TP53 in this network.\n\nggraph(n, layout = \"fr\") +\n  geom_edge_link(alpha = 0.08) +\n  geom_node_point(aes(color = interacts_tp53, shape = is_tp53), size = 2.5) +\n  scale_color_manual(values = c(no = \"grey70\", yes = \"tomato\")) +\n  scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 15)) +\n  geom_node_text(aes(label = ifelse(is_tp53 | interacts_tp53 == \"yes\", name, \"\")),\n                 repel = TRUE, size = 2, max.overlaps = 1000) +\n  theme_void()\n\n\n\n\n\n\n\n\nNow, I will create a subnetwork consisting only of TP53 and its interaction partners, and label it with the corresponding gene names.\nOne way to do this is to use the delete_vertices() function to make a new graph, keeping only the nodes interacting with TP53. Another way to do it is by using induced_subgraph() and only keeping the nodes that are neighbours to TP53.\n\nkeep_vs &lt;- c(tp, tp_neighbors) # Concatenates all the neighbors and tp into a single vertex sequence. These are the ones we are keeping.\n\ntp53_ego &lt;- induced_subgraph(n, vids = keep_vs) #the induced_subgraph function takes n, and builds a new graph with only the vertices I decide to keep. These are denoted by the argument vids (stands for vertex identifiers). the object is called ego, because an ego-network (or ego-centric network) is the local subgraph centered on a focal actor (the ego) and their direct connections (alters).\n\n\nggraph(tp53_ego, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) + \n  geom_node_point(aes(color = ifelse(name == \"TP53\", \"TP53\", \"Partner\")), size = 3) +\n  scale_color_manual(values = c(TP53 = \"tomato\", Partner = \"steelblue\")) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) # label by 'name' (gene symbol) +\n\n\n\n\n\n\n\n  theme_void()\n\n&lt;theme&gt; List of 144\n $ line                            : &lt;ggplot2::element_blank&gt;\n $ rect                            : &lt;ggplot2::element_rect&gt;\n  ..@ fill         : chr \"#00000000\"\n  ..@ colour       : logi NA\n  ..@ linewidth    : num 0\n  ..@ linetype     : num 1\n  ..@ linejoin     : chr \"round\"\n  ..@ inherit.blank: logi TRUE\n $ text                            : &lt;ggplot2::element_text&gt;\n  ..@ family       : chr \"\"\n  ..@ face         : chr \"plain\"\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : chr \"black\"\n  ..@ size         : num 11\n  ..@ hjust        : num 0.5\n  ..@ vjust        : num 0.5\n  ..@ angle        : num 0\n  ..@ lineheight   : num 0.9\n  ..@ margin       : &lt;ggplot2::margin&gt; num [1:4] 0 0 0 0\n  ..@ debug        : logi FALSE\n  ..@ inherit.blank: logi TRUE\n $ title                           : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : NULL\n  ..@ hjust        : NULL\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ point                           : &lt;ggplot2::element_blank&gt;\n $ polygon                         : &lt;ggplot2::element_blank&gt;\n $ geom                            : &lt;ggplot2::element_geom&gt;\n  ..@ ink        : chr \"black\"\n  ..@ paper      : chr \"#00000000\"\n  ..@ accent     : chr \"#3366FF\"\n  ..@ linewidth  : num 0.5\n  ..@ borderwidth: num 0.5\n  ..@ linetype   : int 1\n  ..@ bordertype : int 1\n  ..@ family     : chr \"\"\n  ..@ fontsize   : num 3.87\n  ..@ pointsize  : num 1.5\n  ..@ pointshape : num 19\n  ..@ colour     : NULL\n  ..@ fill       : NULL\n $ spacing                         : 'simpleUnit' num 5.5points\n  ..- attr(*, \"unit\")= int 8\n $ margins                         : &lt;ggplot2::margin&gt; num [1:4] 5.5 5.5 5.5 5.5\n $ aspect.ratio                    : NULL\n $ axis.title                      : &lt;ggplot2::element_blank&gt;\n $ axis.title.x                    : NULL\n $ axis.title.x.top                : NULL\n $ axis.title.x.bottom             : NULL\n $ axis.title.y                    : NULL\n $ axis.title.y.left               : NULL\n $ axis.title.y.right              : NULL\n $ axis.text                       : &lt;ggplot2::element_blank&gt;\n $ axis.text.x                     : NULL\n $ axis.text.x.top                 : NULL\n $ axis.text.x.bottom              : NULL\n $ axis.text.y                     : NULL\n $ axis.text.y.left                : NULL\n $ axis.text.y.right               : NULL\n $ axis.text.theta                 : NULL\n $ axis.text.r                     : NULL\n $ axis.ticks                      : NULL\n $ axis.ticks.x                    : NULL\n $ axis.ticks.x.top                : NULL\n $ axis.ticks.x.bottom             : NULL\n $ axis.ticks.y                    : NULL\n $ axis.ticks.y.left               : NULL\n $ axis.ticks.y.right              : NULL\n $ axis.ticks.theta                : NULL\n $ axis.ticks.r                    : NULL\n $ axis.minor.ticks.x.top          : NULL\n $ axis.minor.ticks.x.bottom       : NULL\n $ axis.minor.ticks.y.left         : NULL\n $ axis.minor.ticks.y.right        : NULL\n $ axis.minor.ticks.theta          : NULL\n $ axis.minor.ticks.r              : NULL\n $ axis.ticks.length               : 'rel' num 0\n $ axis.ticks.length.x             : NULL\n $ axis.ticks.length.x.top         : NULL\n $ axis.ticks.length.x.bottom      : NULL\n $ axis.ticks.length.y             : NULL\n $ axis.ticks.length.y.left        : NULL\n $ axis.ticks.length.y.right       : NULL\n $ axis.ticks.length.theta         : NULL\n $ axis.ticks.length.r             : NULL\n $ axis.minor.ticks.length         : NULL\n $ axis.minor.ticks.length.x       : NULL\n $ axis.minor.ticks.length.x.top   : NULL\n $ axis.minor.ticks.length.x.bottom: NULL\n $ axis.minor.ticks.length.y       : NULL\n $ axis.minor.ticks.length.y.left  : NULL\n $ axis.minor.ticks.length.y.right : NULL\n $ axis.minor.ticks.length.theta   : NULL\n $ axis.minor.ticks.length.r       : NULL\n $ axis.line                       : NULL\n $ axis.line.x                     : NULL\n $ axis.line.x.top                 : NULL\n $ axis.line.x.bottom              : NULL\n $ axis.line.y                     : NULL\n $ axis.line.y.left                : NULL\n $ axis.line.y.right               : NULL\n $ axis.line.theta                 : NULL\n $ axis.line.r                     : NULL\n $ legend.background               : &lt;ggplot2::element_blank&gt;\n $ legend.margin                   : &lt;ggplot2::margin&gt; num [1:4] 0 0 0 0\n $ legend.spacing                  : NULL\n $ legend.spacing.x                : NULL\n $ legend.spacing.y                : NULL\n $ legend.key                      : NULL\n $ legend.key.size                 : 'simpleUnit' num 1.2lines\n  ..- attr(*, \"unit\")= int 3\n $ legend.key.height               : NULL\n $ legend.key.width                : NULL\n $ legend.key.spacing              : 'rel' num 1\n $ legend.key.spacing.x            : NULL\n $ legend.key.spacing.y            : NULL\n $ legend.key.justification        : NULL\n $ legend.frame                    : &lt;ggplot2::element_blank&gt;\n $ legend.ticks                    : NULL\n $ legend.ticks.length             : 'rel' num 0.2\n $ legend.axis.line                : NULL\n $ legend.text                     : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : 'rel' num 0.8\n  ..@ hjust        : NULL\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ legend.text.position            : NULL\n $ legend.title                    : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : NULL\n  ..@ hjust        : num 0\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ legend.title.position           : NULL\n $ legend.position                 : chr \"right\"\n $ legend.position.inside          : NULL\n $ legend.direction                : NULL\n $ legend.byrow                    : NULL\n $ legend.justification            : NULL\n $ legend.justification.top        : NULL\n $ legend.justification.bottom     : NULL\n $ legend.justification.left       : NULL\n $ legend.justification.right      : NULL\n $ legend.justification.inside     : NULL\n  [list output truncated]\n @ complete: logi TRUE\n @ validate: logi TRUE\n\n\nNow lets do it with delete_vertices()\n\nkeep_vs &lt;- c(tp, tp_neighbors) # so this is the same across both\ndrop_vs &lt;- V(n)[!(V(n) %in% keep_vs)] # but now there is this line, which makes it less straightforward compared to induced_subgraph(). this is basically everything in n, but not in keep_vs. \n\ntp53_ego2 &lt;- delete_vertices(n, drop_vs)\nggraph(tp53_ego2, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) + \n  geom_node_point(aes(color = ifelse(name == \"TP53\", \"TP53\", \"Partner\")), size = 3) +\n  scale_color_manual(values = c(TP53 = \"tomato\", Partner = \"steelblue\")) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) # label by 'name' (gene symbol) +\n\n\n\n\n\n\n\n  theme_void()\n\n&lt;theme&gt; List of 144\n $ line                            : &lt;ggplot2::element_blank&gt;\n $ rect                            : &lt;ggplot2::element_rect&gt;\n  ..@ fill         : chr \"#00000000\"\n  ..@ colour       : logi NA\n  ..@ linewidth    : num 0\n  ..@ linetype     : num 1\n  ..@ linejoin     : chr \"round\"\n  ..@ inherit.blank: logi TRUE\n $ text                            : &lt;ggplot2::element_text&gt;\n  ..@ family       : chr \"\"\n  ..@ face         : chr \"plain\"\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : chr \"black\"\n  ..@ size         : num 11\n  ..@ hjust        : num 0.5\n  ..@ vjust        : num 0.5\n  ..@ angle        : num 0\n  ..@ lineheight   : num 0.9\n  ..@ margin       : &lt;ggplot2::margin&gt; num [1:4] 0 0 0 0\n  ..@ debug        : logi FALSE\n  ..@ inherit.blank: logi TRUE\n $ title                           : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : NULL\n  ..@ hjust        : NULL\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ point                           : &lt;ggplot2::element_blank&gt;\n $ polygon                         : &lt;ggplot2::element_blank&gt;\n $ geom                            : &lt;ggplot2::element_geom&gt;\n  ..@ ink        : chr \"black\"\n  ..@ paper      : chr \"#00000000\"\n  ..@ accent     : chr \"#3366FF\"\n  ..@ linewidth  : num 0.5\n  ..@ borderwidth: num 0.5\n  ..@ linetype   : int 1\n  ..@ bordertype : int 1\n  ..@ family     : chr \"\"\n  ..@ fontsize   : num 3.87\n  ..@ pointsize  : num 1.5\n  ..@ pointshape : num 19\n  ..@ colour     : NULL\n  ..@ fill       : NULL\n $ spacing                         : 'simpleUnit' num 5.5points\n  ..- attr(*, \"unit\")= int 8\n $ margins                         : &lt;ggplot2::margin&gt; num [1:4] 5.5 5.5 5.5 5.5\n $ aspect.ratio                    : NULL\n $ axis.title                      : &lt;ggplot2::element_blank&gt;\n $ axis.title.x                    : NULL\n $ axis.title.x.top                : NULL\n $ axis.title.x.bottom             : NULL\n $ axis.title.y                    : NULL\n $ axis.title.y.left               : NULL\n $ axis.title.y.right              : NULL\n $ axis.text                       : &lt;ggplot2::element_blank&gt;\n $ axis.text.x                     : NULL\n $ axis.text.x.top                 : NULL\n $ axis.text.x.bottom              : NULL\n $ axis.text.y                     : NULL\n $ axis.text.y.left                : NULL\n $ axis.text.y.right               : NULL\n $ axis.text.theta                 : NULL\n $ axis.text.r                     : NULL\n $ axis.ticks                      : NULL\n $ axis.ticks.x                    : NULL\n $ axis.ticks.x.top                : NULL\n $ axis.ticks.x.bottom             : NULL\n $ axis.ticks.y                    : NULL\n $ axis.ticks.y.left               : NULL\n $ axis.ticks.y.right              : NULL\n $ axis.ticks.theta                : NULL\n $ axis.ticks.r                    : NULL\n $ axis.minor.ticks.x.top          : NULL\n $ axis.minor.ticks.x.bottom       : NULL\n $ axis.minor.ticks.y.left         : NULL\n $ axis.minor.ticks.y.right        : NULL\n $ axis.minor.ticks.theta          : NULL\n $ axis.minor.ticks.r              : NULL\n $ axis.ticks.length               : 'rel' num 0\n $ axis.ticks.length.x             : NULL\n $ axis.ticks.length.x.top         : NULL\n $ axis.ticks.length.x.bottom      : NULL\n $ axis.ticks.length.y             : NULL\n $ axis.ticks.length.y.left        : NULL\n $ axis.ticks.length.y.right       : NULL\n $ axis.ticks.length.theta         : NULL\n $ axis.ticks.length.r             : NULL\n $ axis.minor.ticks.length         : NULL\n $ axis.minor.ticks.length.x       : NULL\n $ axis.minor.ticks.length.x.top   : NULL\n $ axis.minor.ticks.length.x.bottom: NULL\n $ axis.minor.ticks.length.y       : NULL\n $ axis.minor.ticks.length.y.left  : NULL\n $ axis.minor.ticks.length.y.right : NULL\n $ axis.minor.ticks.length.theta   : NULL\n $ axis.minor.ticks.length.r       : NULL\n $ axis.line                       : NULL\n $ axis.line.x                     : NULL\n $ axis.line.x.top                 : NULL\n $ axis.line.x.bottom              : NULL\n $ axis.line.y                     : NULL\n $ axis.line.y.left                : NULL\n $ axis.line.y.right               : NULL\n $ axis.line.theta                 : NULL\n $ axis.line.r                     : NULL\n $ legend.background               : &lt;ggplot2::element_blank&gt;\n $ legend.margin                   : &lt;ggplot2::margin&gt; num [1:4] 0 0 0 0\n $ legend.spacing                  : NULL\n $ legend.spacing.x                : NULL\n $ legend.spacing.y                : NULL\n $ legend.key                      : NULL\n $ legend.key.size                 : 'simpleUnit' num 1.2lines\n  ..- attr(*, \"unit\")= int 3\n $ legend.key.height               : NULL\n $ legend.key.width                : NULL\n $ legend.key.spacing              : 'rel' num 1\n $ legend.key.spacing.x            : NULL\n $ legend.key.spacing.y            : NULL\n $ legend.key.justification        : NULL\n $ legend.frame                    : &lt;ggplot2::element_blank&gt;\n $ legend.ticks                    : NULL\n $ legend.ticks.length             : 'rel' num 0.2\n $ legend.axis.line                : NULL\n $ legend.text                     : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : 'rel' num 0.8\n  ..@ hjust        : NULL\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ legend.text.position            : NULL\n $ legend.title                    : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : NULL\n  ..@ hjust        : num 0\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ legend.title.position           : NULL\n $ legend.position                 : chr \"right\"\n $ legend.position.inside          : NULL\n $ legend.direction                : NULL\n $ legend.byrow                    : NULL\n $ legend.justification            : NULL\n $ legend.justification.top        : NULL\n $ legend.justification.bottom     : NULL\n $ legend.justification.left       : NULL\n $ legend.justification.right      : NULL\n $ legend.justification.inside     : NULL\n  [list output truncated]\n @ complete: logi TRUE\n @ validate: logi TRUE\n\n\nThere is actually another way to do that, which is perhaps more convenient than either. It uses the make_ego_graph() function.\n\ntp53_ego3 &lt;- make_ego_graph(n, order = 1, nodes = tp, mode = \"all\")[[1]] # we dont just use the function here because it outputs a list of GRAPHS, so then we use [[1]] to pull the tp-centered ego network out.\n\nggraph(tp53_ego3, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) + \n  geom_node_point(aes(color = ifelse(name == \"TP53\", \"TP53\", \"Partner\")), size = 3) +\n  scale_color_manual(values = c(TP53 = \"tomato\", Partner = \"steelblue\")) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 3) # label by 'name' (gene symbol) +\n\n\n\n\n\n\n\n  theme_void()\n\n&lt;theme&gt; List of 144\n $ line                            : &lt;ggplot2::element_blank&gt;\n $ rect                            : &lt;ggplot2::element_rect&gt;\n  ..@ fill         : chr \"#00000000\"\n  ..@ colour       : logi NA\n  ..@ linewidth    : num 0\n  ..@ linetype     : num 1\n  ..@ linejoin     : chr \"round\"\n  ..@ inherit.blank: logi TRUE\n $ text                            : &lt;ggplot2::element_text&gt;\n  ..@ family       : chr \"\"\n  ..@ face         : chr \"plain\"\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : chr \"black\"\n  ..@ size         : num 11\n  ..@ hjust        : num 0.5\n  ..@ vjust        : num 0.5\n  ..@ angle        : num 0\n  ..@ lineheight   : num 0.9\n  ..@ margin       : &lt;ggplot2::margin&gt; num [1:4] 0 0 0 0\n  ..@ debug        : logi FALSE\n  ..@ inherit.blank: logi TRUE\n $ title                           : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : NULL\n  ..@ hjust        : NULL\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ point                           : &lt;ggplot2::element_blank&gt;\n $ polygon                         : &lt;ggplot2::element_blank&gt;\n $ geom                            : &lt;ggplot2::element_geom&gt;\n  ..@ ink        : chr \"black\"\n  ..@ paper      : chr \"#00000000\"\n  ..@ accent     : chr \"#3366FF\"\n  ..@ linewidth  : num 0.5\n  ..@ borderwidth: num 0.5\n  ..@ linetype   : int 1\n  ..@ bordertype : int 1\n  ..@ family     : chr \"\"\n  ..@ fontsize   : num 3.87\n  ..@ pointsize  : num 1.5\n  ..@ pointshape : num 19\n  ..@ colour     : NULL\n  ..@ fill       : NULL\n $ spacing                         : 'simpleUnit' num 5.5points\n  ..- attr(*, \"unit\")= int 8\n $ margins                         : &lt;ggplot2::margin&gt; num [1:4] 5.5 5.5 5.5 5.5\n $ aspect.ratio                    : NULL\n $ axis.title                      : &lt;ggplot2::element_blank&gt;\n $ axis.title.x                    : NULL\n $ axis.title.x.top                : NULL\n $ axis.title.x.bottom             : NULL\n $ axis.title.y                    : NULL\n $ axis.title.y.left               : NULL\n $ axis.title.y.right              : NULL\n $ axis.text                       : &lt;ggplot2::element_blank&gt;\n $ axis.text.x                     : NULL\n $ axis.text.x.top                 : NULL\n $ axis.text.x.bottom              : NULL\n $ axis.text.y                     : NULL\n $ axis.text.y.left                : NULL\n $ axis.text.y.right               : NULL\n $ axis.text.theta                 : NULL\n $ axis.text.r                     : NULL\n $ axis.ticks                      : NULL\n $ axis.ticks.x                    : NULL\n $ axis.ticks.x.top                : NULL\n $ axis.ticks.x.bottom             : NULL\n $ axis.ticks.y                    : NULL\n $ axis.ticks.y.left               : NULL\n $ axis.ticks.y.right              : NULL\n $ axis.ticks.theta                : NULL\n $ axis.ticks.r                    : NULL\n $ axis.minor.ticks.x.top          : NULL\n $ axis.minor.ticks.x.bottom       : NULL\n $ axis.minor.ticks.y.left         : NULL\n $ axis.minor.ticks.y.right        : NULL\n $ axis.minor.ticks.theta          : NULL\n $ axis.minor.ticks.r              : NULL\n $ axis.ticks.length               : 'rel' num 0\n $ axis.ticks.length.x             : NULL\n $ axis.ticks.length.x.top         : NULL\n $ axis.ticks.length.x.bottom      : NULL\n $ axis.ticks.length.y             : NULL\n $ axis.ticks.length.y.left        : NULL\n $ axis.ticks.length.y.right       : NULL\n $ axis.ticks.length.theta         : NULL\n $ axis.ticks.length.r             : NULL\n $ axis.minor.ticks.length         : NULL\n $ axis.minor.ticks.length.x       : NULL\n $ axis.minor.ticks.length.x.top   : NULL\n $ axis.minor.ticks.length.x.bottom: NULL\n $ axis.minor.ticks.length.y       : NULL\n $ axis.minor.ticks.length.y.left  : NULL\n $ axis.minor.ticks.length.y.right : NULL\n $ axis.minor.ticks.length.theta   : NULL\n $ axis.minor.ticks.length.r       : NULL\n $ axis.line                       : NULL\n $ axis.line.x                     : NULL\n $ axis.line.x.top                 : NULL\n $ axis.line.x.bottom              : NULL\n $ axis.line.y                     : NULL\n $ axis.line.y.left                : NULL\n $ axis.line.y.right               : NULL\n $ axis.line.theta                 : NULL\n $ axis.line.r                     : NULL\n $ legend.background               : &lt;ggplot2::element_blank&gt;\n $ legend.margin                   : &lt;ggplot2::margin&gt; num [1:4] 0 0 0 0\n $ legend.spacing                  : NULL\n $ legend.spacing.x                : NULL\n $ legend.spacing.y                : NULL\n $ legend.key                      : NULL\n $ legend.key.size                 : 'simpleUnit' num 1.2lines\n  ..- attr(*, \"unit\")= int 3\n $ legend.key.height               : NULL\n $ legend.key.width                : NULL\n $ legend.key.spacing              : 'rel' num 1\n $ legend.key.spacing.x            : NULL\n $ legend.key.spacing.y            : NULL\n $ legend.key.justification        : NULL\n $ legend.frame                    : &lt;ggplot2::element_blank&gt;\n $ legend.ticks                    : NULL\n $ legend.ticks.length             : 'rel' num 0.2\n $ legend.axis.line                : NULL\n $ legend.text                     : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : 'rel' num 0.8\n  ..@ hjust        : NULL\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ legend.text.position            : NULL\n $ legend.title                    : &lt;ggplot2::element_text&gt;\n  ..@ family       : NULL\n  ..@ face         : NULL\n  ..@ italic       : chr NA\n  ..@ fontweight   : num NA\n  ..@ fontwidth    : num NA\n  ..@ colour       : NULL\n  ..@ size         : NULL\n  ..@ hjust        : num 0\n  ..@ vjust        : NULL\n  ..@ angle        : NULL\n  ..@ lineheight   : NULL\n  ..@ margin       : NULL\n  ..@ debug        : NULL\n  ..@ inherit.blank: logi TRUE\n $ legend.title.position           : NULL\n $ legend.position                 : chr \"right\"\n $ legend.position.inside          : NULL\n $ legend.direction                : NULL\n $ legend.byrow                    : NULL\n $ legend.justification            : NULL\n $ legend.justification.top        : NULL\n $ legend.justification.bottom     : NULL\n $ legend.justification.left       : NULL\n $ legend.justification.right      : NULL\n $ legend.justification.inside     : NULL\n  [list output truncated]\n @ complete: logi TRUE\n @ validate: logi TRUE"
  },
  {
    "objectID": "nbs/week2-louvian.html#part-iii.-network-statistics",
    "href": "nbs/week2-louvian.html#part-iii.-network-statistics",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Part III. Network statistics",
    "text": "Part III. Network statistics\nNow I will calculate the following statistics for the full network:\n\nAverage node degree (average number of incident edges across the network)\nAverage clustering coefficient (also known as transitivity)\nConcept:\nClustering coefficient = tendency of neighbors of a node to also be connected (i.e. “triangles”).\n\nLocal clustering coefficient: how clustered around a single node.\nGlobal clustering coefficient: average across all nodes (or ratio of closed triplets to all triplets).\n\nNetwork diameter\nConcept:\nThe longest shortest path between any two nodes in the graph.\nIn other words, how far apart the most distant nodes are (measured in steps).\n\n\ndeg &lt;- degree(n, mode = \"all\") # degree of every vertex\nmean(deg) # average degree\n\n[1] 5.198091\n\ntransitivity(n, type = \"average\") # mean of local clustering coefficients over all nodes.(Skip nodes with degree &lt; 2, since clustering coefficient is undefined there.))\n\n[1] 0.1609234\n\ndiameter(n, directed = FALSE)  # since the graph is undirected\n\n[1] 4\n\n\nNow we will make a plot of the distribution of node degrees.\n\ndeg &lt;- degree(n)\n\nhist(deg, # the data vector (degrees for all nodes).\n     breaks = 50, # Divide the x-axis (degree values) into 50 bins. More bins → more detail; fewer bins → smoother but less detail.\n     main   = \"Node Degree Distribution\", #The title of the plot\n     xlab   = \"Degree\", #Label of the x-axis. Here it represents the degree value (number of neighbors).\n     ylab   = \"Frequency\", # Label of the y-axis. It shows how many nodes fall into each degree bin.\n     col    = \"lightblue\", #Fills the bars of the histogram with light blue color.\n     border = \"white\" #Sets the outline color of the bars to white, making the bars visually cleaner.\n     )\ntp_deg &lt;- degree(n, v = V(n)[name == \"TP53\"])\nabline(v = tp_deg, col = \"red\", lwd = 2)  # adds vertical line at TP53's degree. lwd denotes the line width.\n\n\n\n\n\n\n\n\nSo here we can see that the degree of TP53 is literally off the chart. That clearly means it’s an important protein in this network. But that’s because the whole dataset consists of proteins that interact with the transcription factor TP53 (also known as P53).\nNow I will calculate the node-wise clustering coefficient. This is done with the transitivity() function, setting the variable type = “local”. And plot a histogram, like before.\n\nclust &lt;- transitivity(n, type = \"local\")\n\nhist(clust,\n     breaks = 50,\n     main   = \"Local Clustering Coefficient Distribution\",\n     xlab   = \"Clustering Coefficient\",\n     ylab   = \"Frequency\",\n     col    = \"lightgreen\", border = \"white\")\ntp_clust &lt;- clust[which(V(n)$name == \"TP53\")]\nabline(v = tp_clust, col = \"red\", lwd = 2)\n\n\n\n\n\n\n\ntp_clust\n\n      TP53 \n0.01177675 \n\n\nSo, perhaps unexpectedly, we can see that TP53 has a clustering coefficient of 0.012. That means that TP53 is important, as it connects to proteins that themselves are not interconnected, influencing otherwise separate groups."
  },
  {
    "objectID": "nbs/week2-louvian.html#part-iv.-network-clustering",
    "href": "nbs/week2-louvian.html#part-iv.-network-clustering",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Part IV. Network clustering",
    "text": "Part IV. Network clustering"
  },
  {
    "objectID": "nbs/week2-louvian.html#louvain-clustering",
    "href": "nbs/week2-louvian.html#louvain-clustering",
    "title": "Week 2: Network topology, statistics, and clustering",
    "section": "Louvain clustering",
    "text": "Louvain clustering\n\nConcept\n\nGoal: partition the network into subclusters (communities) such that nodes are densely connected within clusters and more sparsely connected between clusters.\nAlgorithm: Louvain clustering maximizes modularity (a score of how well the network splits into modules). This makes the graph much much more easily comprehensible visually, as you will see.\nResolution parameter: controls the granularity.\n\nLow resolution → fewer, larger clusters.\nHigh resolution → more, smaller clusters.\nThis is adjusted manually to see what best reveals structure.\n\n\n\n\nResolution: too low → one or two giant clusters; too high → many tiny clusters.\nCluster numbers: They are arbitrary (cluster #2 doesn’t mean “second most important”). A good idea is to inspect the size with table(membership_vec).\nDisconnected components: Diameter and clustering coefficient are only meaningful if the cluster has at least a few nodes.\n\n\n# Running Louvain clustering\ncl &lt;- cluster_louvain(n, resolution = 2) #We will start with resolution of 1.\n\n# Each vertex gets a cluster membership\nmembership_vec &lt;- membership(cl)\n# ChatGPT explanation:\n# membership(): extracts the cluster ID for each vertex from the community object cl.\n# Result: membership_vec is an integer vector of length = number of nodes in your graph.\n# Example:\n# [1] 1 1 2 2 2 3 1 3 ...\n# Each entry corresponds to one vertex (in the same order as V(n)), and the number is the cluster label.\n# So if membership_vec[10] = 2, that means vertex 10 belongs to cluster 2.\n# Cluster labels are arbitrary integers (1, 2, 3, …). They don’t imply ranking or importance, just grouping.\n\n# How many clusters?\nlength(unique(membership_vec))\n\n[1] 23\n\ntable(membership_vec)   # size of each cluster\n\nmembership_vec\n 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \n20 25 14 18 32 21 18 16 22  8 18 12 31 19 13 27 13 14 19 26 16  9  8 \n\nggraph(n, layout = \"fr\") +\n  geom_edge_link(alpha = 0.05) +\n  geom_node_point(aes(color = factor(membership_vec)), size = 2) +\n  geom_node_text(aes(label = ifelse(name == \"TP53\", name, \"\")),\n                 repel = TRUE, color = \"black\", size = 3) +\n  theme_void()\n\n\n\n\n\n\n\n\nAnd finally, we can now extract a sub-network from cluster two and calculate the statistics, just like before:\n\nsub_nodes &lt;- V(n)[membership_vec == 2]\ncluster2 &lt;- induced_subgraph(n, vids = sub_nodes)\n# Average degree\ndeg2 &lt;- degree(cluster2)\nmean(deg2)\n\n[1] 3.84\n\nhist(deg2, # the data vector (degrees for all nodes).\n     breaks = 50, # Divide the x-axis (degree values) into 50 bins. More bins → more detail; fewer bins → smoother but less detail.\n     main   = \"Node Degree Distribution of Cluster 2\", #The title of the plot\n     xlab   = \"Degree\", #Label of the x-axis. Here it represents the degree value (number of neighbors).\n     ylab   = \"Frequency\", # Label of the y-axis. It shows how many nodes fall into each degree bin.\n     col    = \"lightblue\", #Fills the bars of the histogram with light blue color.\n     border = \"white\" #Sets the outline color of the bars to white, making the bars visually cleaner.\n     )\n\n\n\n\n\n\n\n# Average clustering coefficient\ntransitivity(cluster2, type = \"average\")\n\n[1] 0.400449\n\nsub_clust &lt;- transitivity(cluster2, type = \"local\")\n\nhist(sub_clust,\n     breaks = 50,\n     main   = \"Local Clustering Coefficient Distribution of Cluster 2\",\n     xlab   = \"Clustering Coefficient\",\n     ylab   = \"Frequency\",\n     col    = \"lightgreen\", border = \"white\")\n\n\n\n\n\n\n\n# Diameter\ndiameter(cluster2, directed = FALSE)\n\n[1] 5\n\nggraph(cluster2, layout = \"fr\") +\n  geom_edge_link(alpha = 0.1) +\n  geom_node_point(color = \"steelblue\", size = 3) +\n  geom_node_text(aes(label = name), repel = TRUE, size = 2) +\n  theme_void()\n\n\n\n\n\n\n\n\nThat’s all!"
  },
  {
    "objectID": "notebooks.html",
    "href": "notebooks.html",
    "title": "Notebooks",
    "section": "",
    "text": "Browse the notebooks below.\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nWeek 4: Heart Disease and Virtual Pulldown\n\n\n\nVirtual Pulldown\n\nNetwork Characterization\n\nDisease case study\n\n\n\nOverall objective: learn how to extract meaningful networks from human PPI data\n\n\n\nSep 25, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 3: Gene Ontology\n\n\n\nGene Ontology\n\nEnrichment Analysis\n\nfgsea\n\n\n\n\n\n\n\nSep 18, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 2: Network topology, statistics, and clustering\n\n\n\nNetwork topology\n\nClustering\n\nAdvanced Visualization\n\n\n\n\n\n\n\nSep 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1: Introduction to igraph\n\n\n\nBasics\n\nVisualization\n\n\n\nLearn the basics of network visualization with igraph for systems biology.\n\n\n\nSep 4, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "nbs/Week-4-virtual-pulldown.html",
    "href": "nbs/Week-4-virtual-pulldown.html",
    "title": "Week 4: Heart Disease and Virtual Pulldown",
    "section": "",
    "text": "Learning objectives:\n\nOverall objective: learn how to extract meaningful networks from human PPI data\n\nVirtual pulldowns: sampling 1st order networks and filtering “sticky proteins”\nFinding tightly connected clusters in larger networks\nUsing R to extract, analyze, interpret and visualize (sub)networks.\n\n\nIn this exercise we’ll be working with two different approaches to network characterization:\n\nBuilding a network “bottom-up” - sampling the 1st order interaction partners for a list of input proteins (“Virtual pulldowns”)\nTopology based clustering on large input networks, followed by a search for cluster enriched in disease-related proteins\n\n\n# Libraries needed\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\nlibrary(msigdbr)\nlibrary(fgsea)\n\nWarning: package 'fgsea' was built under R version 4.5.1\n\nlibrary(ggraph)\n\nLoading required package: ggplot2\n\n# The PPI database we will use is InWeb, created at DTU. Note that it has a confidence score (cs-score) telling us how certain we about each interaction.:\nload(file='data/exercise4.Rdata')"
  },
  {
    "objectID": "nbs/Week-4-virtual-pulldown.html#heart-disease-and-virtual-pulldown",
    "href": "nbs/Week-4-virtual-pulldown.html#heart-disease-and-virtual-pulldown",
    "title": "Week 4: Heart Disease and Virtual Pulldown",
    "section": "",
    "text": "Learning objectives:\n\nOverall objective: learn how to extract meaningful networks from human PPI data\n\nVirtual pulldowns: sampling 1st order networks and filtering “sticky proteins”\nFinding tightly connected clusters in larger networks\nUsing R to extract, analyze, interpret and visualize (sub)networks.\n\n\nIn this exercise we’ll be working with two different approaches to network characterization:\n\nBuilding a network “bottom-up” - sampling the 1st order interaction partners for a list of input proteins (“Virtual pulldowns”)\nTopology based clustering on large input networks, followed by a search for cluster enriched in disease-related proteins\n\n\n# Libraries needed\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\nlibrary(msigdbr)\nlibrary(fgsea)\n\nWarning: package 'fgsea' was built under R version 4.5.1\n\nlibrary(ggraph)\n\nLoading required package: ggplot2\n\n# The PPI database we will use is InWeb, created at DTU. Note that it has a confidence score (cs-score) telling us how certain we about each interaction.:\nload(file='data/exercise4.Rdata')"
  },
  {
    "objectID": "nbs/Week-4-virtual-pulldown.html#exercise-on-virtual-pulldowns",
    "href": "nbs/Week-4-virtual-pulldown.html#exercise-on-virtual-pulldowns",
    "title": "Week 4: Heart Disease and Virtual Pulldown",
    "section": "Exercise on “Virtual Pulldowns”",
    "text": "Exercise on “Virtual Pulldowns”\nWe’ll start out with a set of proteins known to be involved in atrioventricular canal morphology (“AACM”):\n\nseeds &lt;- c(\"ALDH1A2\", \"BMP2\", \"CXADR\", \"GATA4\", \"HAS2\", \"NF1\", \"NKX2-5\", \"PITX2\", \"PKD2\", \"RXRA\", \"TBX1\", \"TBX2\", \"ZFPM1\", \"ZFPM2\")\n\nI will now extract all the connections from the network with a confidence score &gt;= 0.2.\n\n# Filter edges by confidence score\ninWeb_filtered &lt;- subset(inWeb, inweb_cs &gt;= 0.2)\n\n# Build igraph graph\ng &lt;- graph_from_data_frame(d = inWeb_filtered, directed = FALSE)\n\n# Quick check\ng\n\nIGRAPH d3a4ce9 UN-- 12396 204070 -- \n+ attr: name (v/c), inweb_cs (e/n)\n+ edges from d3a4ce9 (vertex names):\n [1] TTC26--KIF3C    TTC26--KIF3B    TTC26--DYNLL1   TTC26--IFT88   \n [5] TTC26--TTC21B   TTC26--IFT20    TTC26--TTC30B   TTC26--DYNC2H1 \n [9] TTC26--WDR19    TTC26--DYNC2LI1 TTC26--TRAF3IP1 TTC26--DYNLRB2 \n[13] TTC26--DYNC2I1  TTC26--IFT81    TTC26--KIFAP3   TTC26--CLUAP1  \n[17] TTC26--DYNC2I2  TTC26--DYNLL2   TTC26--IFT43    TTC26--IFT74   \n[21] TTC26--IFT140   TTC26--IFT27    TTC26--IFT22    TTC26--IFT122  \n[25] TTC26--DYNLRB1  TTC26--IFT46    TTC26--IFT57    TTC26--IFT80   \n[29] TTC26--WDR35    TTC26--IFT172   TTC26--IFT52    TTC26--KIF3A   \n+ ... omitted several edges\n\n\n“IGRAPH f97cc0a UN– 12396 204070” tells us the number of nodes and edges, where 12396 = number of nodes (proteins that remain after filtering) and 204070 = number of edges (interactions with cs ≥ 0.2).\nThe edge list below (TTC26 – KIF3C, etc.) shows some of the actual protein–protein connections. We can also see that inweb_cs is stored as an edge attribute, so we can still access the confidence scores later if needed\nNow, we will do the virtual pulldown as a two-step process. First, we extract the subgraph (aka virtual pulldown), and then we filter it.\n\n\n# Step 1: get neighbors (1st-order) of all seeds\nneighbors_list &lt;- ego(g, order = 1, nodes = seeds, mode = \"all\")\n\n# Flatten into a single vector of nodes\nneighbor_nodes &lt;- unique(unlist(neighbors_list))\n\n# Extract subgraph (the virtual pulldown)\nsub_g &lt;- induced_subgraph(g, vids = neighbor_nodes)\n\nsub_g\n\nIGRAPH ce499e9 UN-- 340 5626 -- \n+ attr: name (v/c), inweb_cs (e/n)\n+ edges from ce499e9 (vertex names):\n [1] BMPR1B--SMAD7   BMPR1B--SMAD9   SMAD7 --SMAD9   MED19 --HDAC3  \n [5] SMAD7 --HDAC3   KMT2D --POLR2D  KMT2D --KDM6A   POLR2D--KDM6A  \n [9] MED19 --MED7    HDAC3 --MED7    BMPR1B--SMAD6   SMAD7 --SMAD6  \n[13] SMAD9 --SMAD6   MED19 --MED14   HDAC3 --MED14   MED7  --MED14  \n[17] HDAC3 --TBL1X   CASK  --SDC3    TBL1X --SIN3B   MED19 --NCOR1  \n[21] HDAC3 --NCOR1   MED7  --NCOR1   MED14 --NCOR1   TBL1X --NCOR1  \n[25] MED19 --MED24   HDAC3 --MED24   MED7  --MED24   MED14 --MED24  \n[29] NCOR1 --MED24   HDAC3 --EED     NCOR1 --EED     MED19 --MED6   \n+ ... omitted several edges\n\n\nThe command ego(g, order = 1, nodes = seeds, mode = “all”) extracts the first-order neighborhood for each of the seed proteins, i.e. the seeds themselves and all proteins directly connected to them by one interaction. Because we set mode = “all”, both incoming and outgoing edges are considered, though in this PPI network the edges are undirected. The function returns a list of ego-networks, one per seed.\nWe then use unlist() to flatten the list into a single vector of protein names, and unique() to remove duplicates, ensuring each protein only appears once.\nThen, induced_subgraph(g, vids = neighbor_nodes) constructs a new graph object that contains only those proteins (the seeds and their neighbors) and all the edges among them. This subgraph is referred to as a “virtual pulldown,” because it computationally simulates the effect of experimentally pulling down a protein and identifying its binding partners.\n\nNow we filter it by fraction-internal cutoff, this is what the filter_virtual_pulldown() function below does.\nFraction-internal cutoff represents what fraction of a node’s connections are inside the pulldown network vs. outside in the whole interactome we are analyzing, which if g (after filtering for confidence scores of &gt;= 0.2).\n\n# Step 2: Filter the virtual pulldown to remove \"sticky\" hub proteins\n# Function takes a subgraph, the full parent graph, and a cutoff threshold.\nfilter_virtual_pulldown &lt;- function(subGraph, parentGraph, cutoff) {\n  \n  # --- Check that both graphs have vertex names (proteins identified by name) ---\n  if (is.null(V(subGraph)$name) || is.null(V(parentGraph)$name))\n    stop(\"Both graphs must have vertex 'name' attributes.\")\n  \n  # --- Mode: \"all\" ensures degrees are calculated without direction ---\n  mode &lt;- \"all\"\n  \n  # --- Extract node names from the subgraph ---\n  vn &lt;- V(subGraph)$name\n  \n  # --- Degree in the full graph: total number of connections each node has globally ---\n  deg_full &lt;- degree(parentGraph, v = vn, mode = mode)\n  \n  # --- Degree in the subgraph: number of connections each node has inside the pulldown ---\n  deg_internal &lt;- degree(subGraph, mode = mode)\n  \n  # --- Combine results into a data frame for each node ---\n  res &lt;- data.frame(\n    node          = vn,\n    deg_internal  = deg_internal,\n    deg_full      = deg_full,\n    # Fraction of a node’s total connections that lie within this pulldown\n    frac_internal = ifelse(deg_full &gt; 0, deg_internal / deg_full, NA_real_),\n    stringsAsFactors = FALSE\n  )\n  \n  # --- Keep only nodes that meet the cutoff for internal fraction ---\n  nodes_to_keep &lt;- res$node[!is.na(res$frac_internal) & res$frac_internal &gt;= cutoff]\n  \n  # --- Build a new subgraph using only the kept nodes ---\n  filteredSubGraph &lt;- induced_subgraph(subGraph, vids = V(subGraph)[name %in% nodes_to_keep])\n  \n  # --- Add the fraction value as a vertex attribute (for later inspection) ---\n  V(filteredSubGraph)$frac_internal &lt;- res$frac_internal[match(V(filteredSubGraph)$name, res$node)]\n  \n  # --- Return the filtered network ---\n  filteredSubGraph\n}\n\nNow we will run “filter_virtual_pulldown()” with these cutoffs: 0, 0.2, 0.5, 1.\nSo cutoff = 0 keeps everything. cutoff = 0.2 keeps only proteins where more or equal to 20% of their total connections are inside the pulldown. cutoff = 1 keeps only the proteins whose entire interaction profile is inside the pulldown.\n\n# Apply filter with different cutoffs\nsub_0   &lt;- filter_virtual_pulldown(sub_g, g, cutoff = 0)\nsub_02  &lt;- filter_virtual_pulldown(sub_g, g, cutoff = 0.2)\nsub_05  &lt;- filter_virtual_pulldown(sub_g, g, cutoff = 0.5)\nsub_1   &lt;- filter_virtual_pulldown(sub_g, g, cutoff = 1)\n\n# Summarize number of nodes and edges for each cutoff\nsizes &lt;- sapply(\n  list(no_cutoff = sub_0, cutoff_0.2 = sub_02, cutoff_0.5 = sub_05, cutoff_1 = sub_1),\n  function(x) c(nodes = vcount(x), edges = ecount(x))\n)\nsizes\n\n      no_cutoff cutoff_0.2 cutoff_0.5 cutoff_1\nnodes       340        251        149       37\nedges      5626       3041       1360      110\n\n\nThe table here shows a clear and expected trend – the higher the cutoff, the fewer nodes and edges.\nNow we plot the one with cutoff of 0.2:\n\n# too large for Kamada-Kawai\nggraph(sub_02, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3) + \n  geom_node_point(aes(size = degree(sub_02), color = ifelse(name %in% seeds, \"Seed\", \"Neighbour\")), size = 3) +\n  scale_color_manual(values = c(\"Seed\" = \"tomato\", \"Neighbour\" = \"steelblue\")) +\n  geom_node_text(aes(label = name), repel = FALSE, size = 1) # label by 'name' (gene symbol)\n\n\n\n\n\n\n\n\nNow we will look at the clusters using Louvain clustering (see Week 2) :\n\nset.seed(22140)  # reproducibility\n\n\ncl &lt;- cluster_louvain(sub_02, resolution = 0.4)\nV(sub_02)$cluster &lt;- membership(cl) # This takes the membership vector (a named integer vector where each element is a node, and the value is the community ID it belongs to) and assigns it as a vertex attribute named \"cluster\" to the sub_02. \ncluster_sizes &lt;- sort(table(V(sub_02)$cluster), decreasing = TRUE)\ncluster_sizes[1:3] # see 3, we will only take the top 2-3 out of the 5 found\n\n\n  4   1   3 \n103  71  57 \n\n\nLet’s plot them!\n\n# Split into separate subgraphs for each cluster\nsub_c1 &lt;- induced_subgraph(sub_02, V(sub_02)$cluster == 1)\nsub_c3 &lt;- induced_subgraph(sub_02, V(sub_02)$cluster == 3)\nsub_c4 &lt;- induced_subgraph(sub_02, V(sub_02)$cluster == 4)\n\n# Function to plot a single cluster\nplot_cluster &lt;- function(graph, title) {\n  ggraph(graph, layout = \"kk\") +\n    geom_edge_link(alpha = 0.1, colour = \"grey40\") +\n    geom_node_point(size = 3, aes(color = name %in% seeds)) +\n    geom_node_text(aes(label = name), \n                   repel = FALSE, size = 2, color = \"black\") +\n    scale_color_manual(values = c(\"TRUE\" = \"tomato\", \"FALSE\" = \"steelblue\"),\n                       labels = c(\"Neighbour\", \"Seed\")) +\n    ggtitle(title) +\n    theme_void()\n}\n\n# Plot clusters separately\nplot_cluster(sub_c1, \"Cluster 1\")\n\n\n\n\n\n\n\nplot_cluster(sub_c3, \"Cluster 3\")\n\n\n\n\n\n\n\nplot_cluster(sub_c4, \"Cluster 4 (largest)\")\n\n\n\n\n\n\n\n\nAlright, so now we will use the 2-3 largest clusters to do gene-set overrepressentation analysis (ORA) with fora() (first mentioned in Week 3).\nTarget = the genes in the cluster.\nUniverse (aka background) = all the genes that could have been chosen in this analysis.\nHere, our universe is all the proteins in the filtered pulldown network (V(sub_02)$name).\nWhy not the full interactome (g) I hear you ask! Because we didn’t give fora() the chance to pick from those, since the clustering only operated on sub_02. Using g as background would inflate significance.\nSo:\n\nuniverse &lt;- V(sub_02)$name\nBP_df &lt;- msigdbr(species = \"human\", category = \"C5\", subcategory = \"BP\")\n\nWarning: The `category` argument of `msigdbr()` is deprecated as of msigdbr 10.0.0.\nℹ Please use the `collection` argument instead.\n\n\nWarning: The `subcategory` argument of `msigdbr()` is deprecated as of msigdbr 10.0.0.\nℹ Please use the `subcollection` argument instead.\n\nBP_list &lt;- split(BP_df$gene_symbol, BP_df$gs_name)\n\n# Now we need to clean the gene sets, just like in Week 3. \nclean_sets &lt;- function(pathways, universe){\n  sets &lt;- lapply(pathways, function(g) intersect(unique(g), universe))\n  sets[vapply(sets, length, integer(1)) &gt; 0]\n}\nBP_list &lt;- clean_sets(BP_list, universe = V(sub_02)$name)\n\n# We know the largest clusters, so now we just take the gene names of the genes in each of those clusters. \n\ncl1_genes &lt;- V(sub_02)$name[V(sub_02)$cluster == 1]\ncl3_genes &lt;- V(sub_02)$name[V(sub_02)$cluster == 3]\ncl4_genes &lt;- V(sub_02)$name[V(sub_02)$cluster == 4]\n\n# And run ORA with fora()! \nres_cl1 &lt;- fora(BP_list, genes = cl1_genes, universe = universe)\nres_cl3 &lt;- fora(BP_list, genes = cl3_genes, universe = universe)\nres_cl4 &lt;- fora(BP_list, genes = cl4_genes, universe = universe)\n\n# Then we write a simple function to get the enrichment\n\nadd_enrichment &lt;- function(res, universe, target){\n  expected   &lt;- (res$size / length(universe)) * length(target)\n  enrichment &lt;- res$overlap / expected\n  out &lt;- cbind(res, expected, enrichment)\n  out[order(res$padj, res$pval), ]\n}\n\nres_cl1 &lt;- add_enrichment(res_cl1, universe, cl1_genes)\nres_cl3 &lt;- add_enrichment(res_cl3, universe, cl3_genes)\nres_cl4 &lt;- add_enrichment(res_cl4, universe, cl4_genes)\n\nhead(res_cl1[, c(\"pathway\",\"overlap\",\"size\",\"expected\",\"enrichment\",\"pval\",\"padj\")], 10)\n\n                                                               pathway overlap\n                                                                &lt;char&gt;   &lt;int&gt;\n 1:              GOBP_RNA_POLYMERASE_II_PREINITIATION_COMPLEX_ASSEMBLY      27\n 2: GOBP_POSITIVE_REGULATION_OF_DNA_TEMPLATED_TRANSCRIPTION_ELONGATION      26\n 3:                  GOBP_TRANSCRIPTION_PREINITIATION_COMPLEX_ASSEMBLY      27\n 4: GOBP_POSITIVE_REGULATION_OF_DNA_TEMPLATED_TRANSCRIPTION_INITIATION      28\n 5:          GOBP_REGULATION_OF_DNA_TEMPLATED_TRANSCRIPTION_INITIATION      29\n 6:                        GOBP_DNA_TEMPLATED_TRANSCRIPTION_ELONGATION      26\n 7:          GOBP_REGULATION_OF_DNA_TEMPLATED_TRANSCRIPTION_ELONGATION      26\n 8:        GOBP_TRANSCRIPTION_INITIATION_AT_RNA_POLYMERASE_II_PROMOTER      31\n 9:                        GOBP_DNA_TEMPLATED_TRANSCRIPTION_INITIATION      31\n10:                       GOBP_PROTEIN_CONTAINING_COMPLEX_ORGANIZATION      34\n     size  expected enrichment         pval         padj\n    &lt;int&gt;     &lt;num&gt;      &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1:    28  7.920319   3.408954 5.008747e-16 1.810161e-12\n 2:    27  7.637450   3.404278 2.405460e-15 4.346666e-12\n 3:    29  8.203187   3.291404 5.881541e-15 7.085296e-12\n 4:    33  9.334661   2.999573 3.638659e-13 2.878658e-10\n 5:    35  9.900398   2.929175 3.982648e-13 2.878658e-10\n 6:    30  8.486056   3.063850 1.277860e-12 6.597407e-10\n 7:    30  8.486056   3.063850 1.277860e-12 6.597407e-10\n 8:    44 12.446215   2.490717 1.141799e-10 5.158079e-08\n 9:    45 12.729084   2.435368 2.986914e-10 1.199412e-07\n10:    64 18.103586   1.878081 7.827767e-07 2.828955e-04\n\nhead(res_cl3[, c(\"pathway\",\"overlap\",\"size\",\"expected\",\"enrichment\",\"pval\",\"padj\")], 10)\n\n                                                                                        pathway\n                                                                                         &lt;char&gt;\n 1:                                       GOBP_ENZYME_LINKED_RECEPTOR_PROTEIN_SIGNALING_PATHWAY\n 2:                GOBP_CELL_SURFACE_RECEPTOR_PROTEIN_SERINE_THREONINE_KINASE_SIGNALING_PATHWAY\n 3:                                                          GOBP_PATTERN_SPECIFICATION_PROCESS\n 4:                                                                        GOBP_RESPONSE_TO_BMP\n 5:                                                       GOBP_SMAD_PROTEIN_SIGNAL_TRANSDUCTION\n 6: GOBP_REGULATION_OF_TRANSMEMBRANE_RECEPTOR_PROTEIN_SERINE_THREONINE_KINASE_SIGNALING_PATHWAY\n 7:                                                              GOBP_RESPONSE_TO_GROWTH_FACTOR\n 8:                                                                           GOBP_OSSIFICATION\n 9:                                                     GOBP_ACTIVIN_RECEPTOR_SIGNALING_PATHWAY\n10:                                                    GOBP_REGULATION_OF_BMP_SIGNALING_PATHWAY\n    overlap  size  expected enrichment         pval         padj\n      &lt;int&gt; &lt;int&gt;     &lt;num&gt;      &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1:      36    58 13.171315   2.733212 2.525198e-14 5.223250e-11\n 2:      31    44  9.992032   3.102472 2.890564e-14 5.223250e-11\n 3:      35    56 12.717131   2.752193 6.022945e-14 7.255641e-11\n 4:      26    33  7.494024   3.469431 1.190609e-13 1.075715e-10\n 5:      17    18  4.087649   4.158869 2.094583e-11 1.513965e-08\n 6:      25    36  8.175299   3.057992 6.261322e-11 3.771403e-08\n 7:      34    63 14.306773   2.376497 1.093134e-10 5.643697e-08\n 8:      27    43  9.764940   2.764994 2.834229e-10 1.280363e-07\n 9:      13    13  2.952191   4.403509 1.332428e-09 5.350438e-07\n10:      15    17  3.860558   3.885449 4.216542e-09 1.523858e-06\n\nhead(res_cl4[, c(\"pathway\",\"overlap\",\"size\",\"expected\",\"enrichment\",\"pval\",\"padj\")], 10)\n\n                                                                         pathway\n                                                                          &lt;char&gt;\n 1:                                                    GOBP_CHROMATIN_REMODELING\n 2:                                                  GOBP_CHROMATIN_ORGANIZATION\n 3:                                GOBP_EPIGENETIC_REGULATION_OF_GENE_EXPRESSION\n 4:                                                 GOBP_CHROMOSOME_ORGANIZATION\n 5:                                                   GOBP_TELOMERE_ORGANIZATION\n 6:                                                 GOBP_NUCLEOSOME_ORGANIZATION\n 7: GOBP_NEGATIVE_REGULATION_OF_NUCLEOBASE_CONTAINING_COMPOUND_METABOLIC_PROCESS\n 8:                            GOBP_NEGATIVE_REGULATION_OF_RNA_METABOLIC_PROCESS\n 9:                       GOBP_NEGATIVE_REGULATION_OF_GENE_EXPRESSION_EPIGENETIC\n10:                                               GOBP_HETEROCHROMATIN_FORMATION\n    overlap  size  expected enrichment         pval         padj\n      &lt;int&gt; &lt;int&gt;     &lt;num&gt;      &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1:      47    55 22.569721   2.082436 2.157256e-14 7.796322e-11\n 2:      50    61 25.031873   1.997453 6.417578e-14 1.159656e-10\n 3:      31    34 13.952191   2.221873 8.629264e-11 1.039539e-07\n 4:      18    19  7.796813   2.308636 5.218318e-07 4.714750e-04\n 5:      14    14  5.745020   2.436893 2.202884e-06 1.592245e-03\n 6:      18    20  8.207171   2.193204 3.410311e-06 2.054144e-03\n 7:      62   109 44.729084   1.386123 6.680146e-06 3.017756e-03\n 8:      62   109 44.729084   1.386123 6.680146e-06 3.017756e-03\n 9:      14    15  6.155378   2.274434 2.146185e-05 8.618126e-03\n10:      13    14  5.745020   2.262829 5.291817e-05 1.912463e-02\n\n\nOK, now i will have ChatGPT do the analysis of the tables – exactly what LLMs are good for."
  },
  {
    "objectID": "nbs/Week-4-virtual-pulldown.html#cluster-1",
    "href": "nbs/Week-4-virtual-pulldown.html#cluster-1",
    "title": "Week 4: Heart Disease and Virtual Pulldown",
    "section": "Cluster 1",
    "text": "Cluster 1\nTop terms:\n\nTranscription initiation (RNA polymerase II).\nFatty acid metabolic process regulation.\nCholesterol storage.\nInterferon-gamma response.\n\nAACM interpretation:\n\nAt first, lipid and cholesterol processes seem unrelated to embryonic AV canal formation. But notice that one of your seed genes, RXRA, is a nuclear receptor for retinoic acid. Retinoic acid signaling directly regulates endocardial cushion development. Lipid/cholesterol handling is part of how RXRA exerts its function.\nThe immune/inflammatory signal (IFN-γ response) is also not core developmental biology, but inflammation-related pathways do modulate extracellular matrix remodeling in cushions.\nThe transcription-initiation enrichment may reflect the presence of transcription factors like GATA4 and TBX genes, which are central to AACM.\n\nSummary: Cluster 1 looks like a mixed regulatory/metabolic group: transcription factors + lipid metabolism, tying to RXRA’s role in AV cushion formation."
  },
  {
    "objectID": "nbs/Week-4-virtual-pulldown.html#cluster-3",
    "href": "nbs/Week-4-virtual-pulldown.html#cluster-3",
    "title": "Week 4: Heart Disease and Virtual Pulldown",
    "section": "Cluster 3",
    "text": "Cluster 3\nTop terms:\n\nEnzyme-linked receptor signaling.\nBMP/TGF-β signaling.\nGrowth factor response.\nOrgan morphogenesis.\nOssification, SMAD protein signaling.\n\nAACM interpretation:\n\nThis is your canonical developmental cluster. BMP2 and its downstream SMADs drive the epithelial-to-mesenchymal transition (EMT) that seeds mesenchymal cells in the endocardial cushions.\nTBX2, NKX2-5, and GATA4 interact with BMP/TGF-β pathways to regulate atrioventricular septum development.\nOrgan morphogenesis and ossification terms reflect cushion maturation into valve structures.\n\nSummary: Cluster 3 is the heart of AACM biology — direct evidence of the BMP/TGF-β/SMAD axis in endocardial cushion morphogenesis."
  },
  {
    "objectID": "nbs/Week-4-virtual-pulldown.html#cluster-4",
    "href": "nbs/Week-4-virtual-pulldown.html#cluster-4",
    "title": "Week 4: Heart Disease and Virtual Pulldown",
    "section": "Cluster 4",
    "text": "Cluster 4\nTop terms:\n\nChromosome organization, chromatin remodeling.\nHistone modification.\nEpigenetic regulation of gene expression.\n\nAACM interpretation:\n\nThis cluster represents the epigenetic control layer. The TBX, NKX, and GATA transcription factors that pattern the AV canal are tightly controlled by chromatin state.\nMutations in chromatin modifiers (like KMT2D — one of your cluster genes) are known to cause congenital heart defects.\nThus, while not heart-specific, these processes are mechanistically critical for allowing developmental genes to be expressed at the right time/place during AV canal formation.\n\nSummary: Cluster 4 is the epigenetic enabler of AACM gene regulation."
  },
  {
    "objectID": "nbs/Week-4-virtual-pulldown.html#overall-synthesis",
    "href": "nbs/Week-4-virtual-pulldown.html#overall-synthesis",
    "title": "Week 4: Heart Disease and Virtual Pulldown",
    "section": "Overall synthesis",
    "text": "Overall synthesis\n\nCluster 3 → core developmental signaling (BMP/TGF-β/SMAD, morphogenesis) — directly drives atrioventricular canal formation.\nCluster 4 → epigenetic control (chromatin organization, histone modification) — regulates transcription factor activity in cushion development.\nCluster 1 → transcription factors, lipid metabolism, RXRA-related retinoic acid signaling, plus immune modifiers— adds metabolic and regulatory nuance to AACM biology.\n\nTogether, these three clusters make biological sense in AACM: they show developmental signaling, epigenetic regulation, and metabolic/transcriptional modulation.\nBUT! Which gene is most central in the largest cluster (as defined by betweenness centrality) though? And does that make sense in the context of AACM pathology? The largest cluster was 4, so we will take that.\n\n# Betweenness in the largest community (cluster 4)\nsub_c4 &lt;- induced_subgraph(sub_02, V(sub_02)$cluster == 4)\nbc_c4  &lt;- betweenness(sub_c4, directed = FALSE, normalized = TRUE)\n\n# Top by betweenness\ntop_gene_c4 &lt;- names(which.max(bc_c4))\ntop_gene_c4\n\n[1] \"RXRA\"\n\n\nOk, now let’s check out RXRA! RXRA encodes the retinoid X receptor alpha, a transcription factor that mediates retinoic acid signaling. Retinoic acid is known to be essential for atrioventricular canal development, particularly through regulation of endocardial cushion formation. So it does make sense!\n\nHere’s a bit more from ChatGPT on RXRA in the context of the atrioventricular septal defect. And that’s all for today!\n\nRXRA background\n\nRXRA is a nuclear receptor that binds retinoic acid (a vitamin A derivative).\nIt acts as a transcription factor, forming heterodimers with RARs, PPARs, and others.\nIn development, retinoic acid signaling is essential for heart morphogenesis — especially atrial and ventricular septation.\n\n\n\nRXRA in AACM\n\nIn the atrioventricular canal, retinoic acid signaling via RXRA helps regulate endocardial cushion formation.\nEndocardial cushions are precursors to the atrioventricular septum and valves.\nRXRA knockout mice show congenital heart defects, including atrioventricular septal defects, outflow tract malformations, and valve abnormalities.\nSo RXRA is not only relevant — it’s actually directly tied to the disease phenotype you’re studying.\n\n\n\n\nWhy RXRA as “most central” makes sense\n\nNetwork-wise: RXRA interacts with many transcriptional regulators and chromatin-modifying partners. That makes it a bridge between metabolic signals (vitamin A/lipids) and gene expression control.\nBiologically: This fits cluster 4’s “epigenetic regulation” theme — RXRA doesn’t remodel chromatin itself, but it recruits chromatin-modifying complexes to regulate transcription.\nDisease-wise: Because RXRA integrates metabolic cues with gene regulation, its centrality in the network mirrors its central role in AV canal morphogenesis."
  },
  {
    "objectID": "nbs/Week-3-gsea.html",
    "href": "nbs/Week-3-gsea.html",
    "title": "Week 3: Gene Ontology",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.2\n✔ ggplot2   4.0.0     ✔ tibble    3.3.0\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.1.0     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(fgsea)\n\nWarning: package 'fgsea' was built under R version 4.5.1\n\nlibrary(msigdbr)"
  },
  {
    "objectID": "nbs/Week-3-gsea.html#goals",
    "href": "nbs/Week-3-gsea.html#goals",
    "title": "Week 3: Gene Ontology",
    "section": "Goals:",
    "text": "Goals:\nToday we will start working with GSEA!\n\nUnderstand how Gene Ontology terms are defined and organized:\n\nThe relationship between GO terms (IS A, PART OF, etc)\nThe three main trunks of GO: BIOLOGICAL PROCESS, MOLECULAR FUNCTION and CELLULAR COMPONENT.\n\nLearn how to query the Gene Ontology database.\n\nUsing the official online GO query system: AmiGO\nUsing links from UniProt.\n\nUnderstand the theory behind GO over-representation analysis\nLearn how to perform GO over-representation analysis:\n\nUsing the R package “fgsea”\n\n\nFirst, we will investigate “cell division” using AmiGO 2.\nBy clicking on “Graph views”, we can open QuickGO and see how many ancestor and children terms are defined, as well as the different types of relationships they have.\nGO has a few relationship categories. For more information, you can browse the exercises here and do the non-coding exercises to get a feel for the categories: https://teaching.healthtech.dtu.dk/22140/index.php/ExGeneOntology_R. But here is an LLM-generated outline:\n\n🧬 Structural Relationships\n\n\nis_a — “a type of”\nThis is the simplest one.\nThink of it like saying “X is a more specific type of Y.”\n\nExample:\n\nGO:0005739 mitochondrion\nis_a GO:0043231 intracellular membrane-bounded organelle\n\nMeaning: Every mitochondrion is an intracellular membrane-bounded organelle.\n\nPractical use: When you annotate a gene to “mitochondrion,” it automatically counts as being in “intracellular organelle” too. Tools use this to group related things together.\n\n\n\npart_of — “always contained within”\nThis says that wherever X exists, it’s part of Y.\n\nExample:\n\nGO:0000776 kinetochore\npart_of GO:0000775 chromosome, centromeric region\n\nMeaning: Whenever a kinetochore exists, it’s sitting inside the centromeric region of a chromosome.\n\nPractical use: If you see genes annotated to “kinetochore,” you can infer they’re also involved with the centromeric chromosome structure, even if not directly annotated.\n\n\n\nhas_part — “always contains”\nThis is the opposite: if Y exists, it contains X as a piece.\n\nExample:\n\nGO:0005840 ribosome\nhas_part GO:0003735 structural constituent of ribosome\n\nMeaning: Every ribosome has some structural ribosomal proteins inside.\n\nPractical use: This is used more for reasoning than annotation, but helps ontology tools understand what structures are made of."
  },
  {
    "objectID": "nbs/Week-3-gsea.html#functional-process-relationships",
    "href": "nbs/Week-3-gsea.html#functional-process-relationships",
    "title": "Week 3: Gene Ontology",
    "section": "⚙️ Functional / Process Relationships",
    "text": "⚙️ Functional / Process Relationships\n\nregulates — “influences how much / how fast”\nThis links processes that control other processes.\n\nExample:\n\nGO:0048523 negative regulation of cellular process\nregulates GO:0009987 cellular process\n\nMeaning: This is a process that dials down (inhibits) some cellular process.\n\nPractical use: If your gene is involved in regulation, it may not directly perform the target process — it’s a controller, not a worker.\n\n\n\npositively_regulates / negatively_regulates\nThese are more specific kinds of regulates.\n\nExample:\n\nGO:0043065 positive regulation of apoptotic process\npositively_regulates GO:0006915 apoptotic process\n\nMeaning: This process boosts apoptosis.\n(And conversely, “negative regulation” blocks it.)\n\nPractical use: Helps distinguish activators vs. inhibitors of the same pathway in analysis.\n\n\n\noccurs_in — “happens inside”\nThis ties a process to a location.\n\nExample:\n\nGO:0006260 DNA replication\noccurs_in GO:0005634 nucleus\n\nMeaning: DNA replication takes place in the nucleus (in eukaryotes).\n\nPractical use: Lets you connect dynamic events to the cell structures they happen in.\n\n\n\ncapable_of — “can do this”\nThis says a structure can perform a function or process.\n\nExample:\n\nGO:0005665 DNA-directed RNA polymerase II, core complex\ncapable_of GO:0003899 DNA-directed RNA polymerase activity\n\nMeaning: This protein complex can do the activity of RNA polymerase.\n\nPractical use: Connects physical complexes (what something is) to what they do.\n\n\n\n🧠 Logical Notes\n\nGO is structured as a Directed Acyclic Graph (DAG): terms can have multiple parents.\nRelationships define the logical inference engine used by GO tools (like enrichment analysis and ontology reasoners).\nNot all relationships are used in all GO branches; e.g. regulates is only used in biological process branch, while capable_of links cellular components to functions or processes."
  },
  {
    "objectID": "nbs/Week-3-gsea.html#automated-analysis-using-fgsea-and-msigdbr",
    "href": "nbs/Week-3-gsea.html#automated-analysis-using-fgsea-and-msigdbr",
    "title": "Week 3: Gene Ontology",
    "section": "Automated analysis using “fgsea” and “msigdbr”",
    "text": "Automated analysis using “fgsea” and “msigdbr”\nHere are a few tips from ChatGPT before we start:\n\nmsigdbr(...) returns a data frame with columns like gs_name (gene set name) and ensembl_gene (gene IDs).\nfgsea::fora() expects pathways as a named list: list(GENESET1 = c(g1, g2, ...), GENESET2 = c(...)).\nTherefore: you cannot feed the msigdbr data frame directly to fora(). You must convert it with split().\nAlso, your target and background IDs must be in the same ID namespace as the gene sets (we’ll use Ensembl-like yeast ORFs; your ID column looks good).\n\n\n🪐 “Universe” (background)\n\nThe universe is the full set of all genes you could possibly draw from.\nIt’s also called the background list or population group.\nIn your case, it’s the background object you loaded from exercise3_part2.Rdata — a list of all annotated yeast genes.\nfora() uses it to figure out what “random chance” looks like.\nIf 100 out of 5500 genes are DNA repair genes, that’s the baseline probability.\n\nSo:\nUniverse = all yeast genes.\nTarget = your cluster 1 genes.\n\nload(\"data/exercise3_part1.Rdata\")\n\nload(\"data/exercise3_part2.Rdata\")\n\n# From now on, I will personally need a lot of help from ChatGPT, but I will try to decipher everything as well.\n\n# This command retrieves biological process gene sets for yeast. The \"C5\" category is the msigdb annotation for the three gene ontologies. The subcategory is either \"BP\" (biological process), \"MF\" (molecular function), or \"CC\" (cellular component).\n\n# Here we take BP (biological process)\n\nBP_df = msigdbr(species = \"S. cerevisiae\", category = \"C5\", subcategory = \"BP\")\n\nWarning: The `category` argument of `msigdbr()` is deprecated as of msigdbr 10.0.0.\nℹ Please use the `collection` argument instead.\n\n\nWarning: The `subcategory` argument of `msigdbr()` is deprecated as of msigdbr 10.0.0.\nℹ Please use the `subcollection` argument instead.\n\n# Inspect structure and a few rows\ndim(BP_df)          # how many rows & columns?\n\n[1] 108337     26\n\nnames(BP_df)        # column names available\n\n [1] \"gene_symbol\"          \"ncbi_gene\"            \"ensembl_gene\"        \n [4] \"db_gene_symbol\"       \"db_ncbi_gene\"         \"db_ensembl_gene\"     \n [7] \"source_gene\"          \"gs_id\"                \"gs_name\"             \n[10] \"gs_collection\"        \"gs_subcollection\"     \"gs_collection_name\"  \n[13] \"gs_description\"       \"gs_source_species\"    \"gs_pmid\"             \n[16] \"gs_geoid\"             \"gs_exact_source\"      \"gs_url\"              \n[19] \"db_version\"           \"db_target_species\"    \"ortholog_taxon_id\"   \n[22] \"ortholog_sources\"     \"num_ortholog_sources\" \"entrez_gene\"         \n[25] \"gs_cat\"               \"gs_subcat\"           \n\nhead(BP_df[, c(\"gs_name\",\"ensembl_gene\")], 5)   # key columns we’ll use\n\n# A tibble: 5 × 2\n  gs_name                                          ensembl_gene\n  &lt;chr&gt;                                            &lt;chr&gt;       \n1 GOBP_10_FORMYLTETRAHYDROFOLATE_METABOLIC_PROCESS YGR204W     \n2 GOBP_10_FORMYLTETRAHYDROFOLATE_METABOLIC_PROCESS YGR204W     \n3 GOBP_10_FORMYLTETRAHYDROFOLATE_METABOLIC_PROCESS YBR084W     \n4 GOBP_2FE_2S_CLUSTER_ASSEMBLY                     YGL220W     \n5 GOBP_2FE_2S_CLUSTER_ASSEMBLY                     YPL252C     \n\nBP_list = split(x = BP_df$ensembl_gene, f = BP_df$gs_name)\n\n# Inspect to see what one looks like\nlength(BP_list)          # number of gene sets\n\n[1] 5906\n\nnames(BP_list)[1:5]       # first few set names\n\n[1] \"GOBP_10_FORMYLTETRAHYDROFOLATE_METABOLIC_PROCESS\"\n[2] \"GOBP_2_OXOGLUTARATE_METABOLIC_PROCESS\"           \n[3] \"GOBP_2FE_2S_CLUSTER_ASSEMBLY\"                    \n[4] \"GOBP_3_UTR_MEDIATED_MRNA_DESTABILIZATION\"        \n[5] \"GOBP_3_UTR_MEDIATED_MRNA_STABILIZATION\"          \n\nhead(BP_list[[1]], 10)    # genes inside first set\n\n[1] \"YGR204W\" \"YGR204W\" \"YBR084W\"\n\n# Universe: all genes that are \"possible draws\" for this analysis.\n# We take them from the node table's ORF IDs so they match msigdbr's ORF IDs.\nuniverse &lt;- unique(node_attributes$ID)   # unique() removes duplicates\n\n# Then clean BP sets to that universe\nclean_sets &lt;- function(pathways, universe){\n  sets &lt;- lapply(pathways, function(g) intersect(unique(g), universe))\n  sets[vapply(sets, length, integer(1)) &gt; 0]\n}\nBP_list &lt;- clean_sets(BP_list, universe)\n\n# Quick sanity peek:\nlength(universe)     # How big is the universe? (a count)\n\n[1] 300\n\nhead(universe, 5)    # What do these IDs look like? Should be Yxxx... style\n\n[1] \"YLR131C\" \"YNR044W\" \"YGL032C\" \"YBR158W\" \"YGL240W\"\n\n# Target: the actual genes we're testing for enrichment (Cluster #1).\n# Boolean filter: keep rows where the 'cluster' column equals the label \"cluster1\",\n# then pull their ORF IDs and drop duplicates.\ntarget &lt;- unique(node_attributes$ID[node_attributes$cluster == \"cluster1\"])\n\n# Quick sanity peek:\nlength(target)       # How many genes are in Cluster #1?\n\n[1] 17\n\nhead(target, 5)      # Do these look like ORF IDs too?\n\n[1] NA        \"YMR078C\" \"YPR175W\" \"YBR278W\" \"YBL035C\"\n\n# Sanity checks that prevent nonsense results:\nsum(is.na(target))                    # should be 0 (no missing IDs in target)\n\n[1] 1\n\nall(target %in% universe)             # should be TRUE (every target in the universe)\n\n[1] FALSE\n\n# ⚠️ Problem — one of your target entries is NA. That means at least one row in cluster1 had a missing ID.\n\n# Removing it: \n\ntarget &lt;- target[!is.na(target)]\n\n# Rechecking: \n\nlength(target)\n\n[1] 16\n\nall(target %in% universe)\n\n[1] TRUE\n\n# Run over-representation for BP\nres_bp &lt;- fora(pathways = BP_list,   # named list: set -&gt; vector of ORF IDs\n               genes    = target,    # your cluster-1 ORF IDs\n               universe = universe)  # all possible ORF IDs (background)\n\n# See what columns we got back\nnames(res_bp)        # should include: pathway, pval, padj, size, overlap\n\n[1] \"pathway\"        \"pval\"           \"padj\"           \"foldEnrichment\"\n[5] \"overlap\"        \"size\"           \"overlapGenes\"  \n\nhead(res_bp, 5)      # quick peek at the first rows\n\n                                                            pathway\n                                                             &lt;char&gt;\n1:                                    GOBP_DNA_BIOSYNTHETIC_PROCESS\n2:                                             GOBP_DNA_REPLICATION\n3:                               GOBP_DNA_TEMPLATED_DNA_REPLICATION\n4: GOBP_POSITIVE_REGULATION_OF_DNA_DIRECTED_DNA_POLYMERASE_ACTIVITY\n5:                                       GOBP_DNA_METABOLIC_PROCESS\n           pval         padj foldEnrichment overlap  size\n          &lt;num&gt;        &lt;num&gt;          &lt;num&gt;   &lt;int&gt; &lt;int&gt;\n1: 2.333504e-09 5.171045e-06      10.546875       9    16\n2: 7.850384e-09 8.698226e-06       5.625000      12    40\n3: 2.316292e-08 1.710968e-05       6.066176      11    34\n4: 2.230525e-07 1.235711e-04      18.750000       5     5\n5: 4.959087e-07 2.197867e-04       4.090909      12    55\n                                          overlapGenes\n                                                &lt;list&gt;\n1: YMR078C,YNL102W,YNL262W,YPR175W,YOR217W,YOL094C,...\n2: YMR078C,YNL102W,YBL035C,YNL262W,YPR175W,YIR008C,...\n3: YNL102W,YBL035C,YNL262W,YPR175W,YIR008C,YKL045W,...\n4:             YMR078C,YOL094C,YBR087W,YJR068W,YNL290W\n5: YMR078C,YNL102W,YBL035C,YNL262W,YPR175W,YIR008C,...\n\nadd_enrichment &lt;- function(res, universe, target){\n  expected   &lt;- (res$size / length(universe)) * length(target)  # random-draw expectation\n  enrichment &lt;- res$overlap / expected                          # effect size (observed/expected)\n  out &lt;- cbind(res, expected = expected, enrichment = enrichment)\n  out[order(out$padj, out$pval), ]                              # rank by adjusted p-value\n}\n\nres_bp &lt;- add_enrichment(res_bp, universe, target)\n\n# Show top-10 BP terms for your report\ntop10_bp &lt;- head(res_bp[, c(\"pathway\",\"overlap\",\"size\",\"expected\",\"enrichment\",\"pval\",\"padj\")], 10)\ntop10_bp\n\n                                                             pathway overlap\n                                                              &lt;char&gt;   &lt;int&gt;\n 1:                                    GOBP_DNA_BIOSYNTHETIC_PROCESS       9\n 2:                                             GOBP_DNA_REPLICATION      12\n 3:                               GOBP_DNA_TEMPLATED_DNA_REPLICATION      11\n 4: GOBP_POSITIVE_REGULATION_OF_DNA_DIRECTED_DNA_POLYMERASE_ACTIVITY       5\n 5:                                       GOBP_DNA_METABOLIC_PROCESS      12\n 6:             GOBP_POSITIVE_REGULATION_OF_DNA_BIOSYNTHETIC_PROCESS       5\n 7:                      GOBP_REGULATION_OF_DNA_BIOSYNTHETIC_PROCESS       5\n 8:                         GOBP_DNA_REPLICATION_SYNTHESIS_OF_PRIMER       4\n 9:                 GOBP_POSITIVE_REGULATION_OF_TRANSFERASE_ACTIVITY       5\n10:                   GOBP_POSITIVE_REGULATION_OF_CATALYTIC_ACTIVITY       5\n     size  expected enrichment         pval         padj\n    &lt;int&gt;     &lt;num&gt;      &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1:    16 0.8533333  10.546875 2.333504e-09 5.171045e-06\n 2:    40 2.1333333   5.625000 7.850384e-09 8.698226e-06\n 3:    34 1.8133333   6.066176 2.316292e-08 1.710968e-05\n 4:     5 0.2666667  18.750000 2.230525e-07 1.235711e-04\n 5:    55 2.9333333   4.090909 4.959087e-07 2.197867e-04\n 6:     6 0.3200000  15.625000 1.296729e-06 4.105073e-04\n 7:     6 0.3200000  15.625000 1.296729e-06 4.105073e-04\n 8:     4 0.2133333  18.750000 5.501961e-06 1.524043e-03\n 9:     9 0.4800000  10.416667 2.476143e-05 6.096813e-03\n10:    11 0.5866667   8.522727 8.518855e-05 1.716162e-02\n\n\nNow we just repeat the same for CC and MF:\n\n# Get MF & CC from msigdbr\nMF_df &lt;- msigdbr(species = \"S. cerevisiae\", category = \"C5\", subcategory = \"MF\")\nCC_df &lt;- msigdbr(species = \"S. cerevisiae\", category = \"C5\", subcategory = \"CC\")\n\n# Convert to lists\nMF_list &lt;- split(MF_df$ensembl_gene, MF_df$gs_name)\nCC_list &lt;- split(CC_df$ensembl_gene, CC_df$gs_name)\n\n# Clean to your universe\nMF_list &lt;- clean_sets(MF_list, universe)\nCC_list &lt;- clean_sets(CC_list, universe)\n\n# Run fora\nres_mf &lt;- fora(MF_list, target, universe)\nres_cc &lt;- fora(CC_list, target, universe)\n\n# Add enrichment and take top 10\nres_mf  &lt;- add_enrichment(res_mf, universe, target)\nres_cc  &lt;- add_enrichment(res_cc, universe, target)\n\ntop10_mf &lt;- head(res_mf[, c(\"pathway\",\"overlap\",\"size\",\"expected\",\"enrichment\",\"pval\",\"padj\")], 10)\ntop10_cc &lt;- head(res_cc[, c(\"pathway\",\"overlap\",\"size\",\"expected\",\"enrichment\",\"pval\",\"padj\")], 10)\n\ntop10_mf\n\n                                              pathway overlap  size  expected\n                                               &lt;char&gt;   &lt;int&gt; &lt;int&gt;     &lt;num&gt;\n 1:  GOMF_CATALYTIC_ACTIVITY_ACTING_ON_A_NUCLEIC_ACID      11    27 1.4400000\n 2:                    GOMF_DNA_CLAMP_LOADER_ACTIVITY       6     6 0.3200000\n 3:             GOMF_CATALYTIC_ACTIVITY_ACTING_ON_DNA       9    23 1.2266667\n 4:              GOMF_NUCLEOTIDYLTRANSFERASE_ACTIVITY       5     8 0.4266667\n 5:         GOMF_ATP_DEPENDENT_ACTIVITY_ACTING_ON_DNA       6    18 0.9600000\n 6:                        GOMF_DNA_HELICASE_ACTIVITY       5    12 0.6400000\n 7: GOMF_NUCLEIC_ACID_CONFORMATION_ISOMERASE_ACTIVITY       5    12 0.6400000\n 8:        GOMF_SINGLE_STRANDED_DNA_HELICASE_ACTIVITY       5    12 0.6400000\n 9:                      GOMF_ATP_HYDROLYSIS_ACTIVITY       6    22 1.1733333\n10:         GOMF_DNA_DIRECTED_DNA_POLYMERASE_ACTIVITY       3     4 0.2133333\n    enrichment         pval         padj\n         &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1:   7.638889 1.188845e-09 3.875636e-07\n 2:  18.750000 8.317210e-09 1.355705e-06\n 3:   7.336957 1.423523e-07 1.546894e-05\n 4:  11.718750 1.136017e-05 9.258540e-04\n 5:   6.250000 1.077505e-04 5.763922e-03\n 6:   7.812500 1.414459e-04 5.763922e-03\n 7:   7.812500 1.414459e-04 5.763922e-03\n 8:   7.812500 1.414459e-04 5.763922e-03\n 9:   5.113636 3.832597e-04 1.388252e-02\n10:  14.062500 4.862887e-04 1.443644e-02\n\ntop10_cc\n\n                                                               pathway overlap\n                                                                &lt;char&gt;   &lt;int&gt;\n 1:                                              GOCC_REPLICATION_FORK       9\n 2:                                        GOCC_CTF18_RFC_LIKE_COMPLEX       5\n 3:                              GOCC_DNA_REPLICATION_FACTOR_C_COMPLEX       5\n 4:                                        GOCC_DNA_POLYMERASE_COMPLEX       6\n 5:                            GOCC_NUCLEAR_PROTEIN_CONTAINING_COMPLEX      11\n 6:                          GOCC_ALPHA_DNA_POLYMERASE_PRIMASE_COMPLEX       4\n 7:                                        GOCC_RNA_POLYMERASE_COMPLEX       4\n 8: GOCC_TRANSFERASE_COMPLEX_TRANSFERRING_PHOSPHORUS_CONTAINING_GROUPS       6\n 9:                                                     GOCC_REPLISOME       4\n10:                                      GOCC_NUCLEAR_REPLICATION_FORK       4\n     size  expected enrichment         pval         padj\n    &lt;int&gt;     &lt;num&gt;      &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1:    16 0.8533333  10.546875 2.333504e-09 7.443878e-07\n 2:     5 0.2666667  18.750000 2.230525e-07 2.371791e-05\n 3:     5 0.2666667  18.750000 2.230525e-07 2.371791e-05\n 4:     9 0.4800000  12.500000 6.391686e-07 5.097370e-05\n 5:    56 2.9866667   3.683036 8.141989e-06 5.194589e-04\n 6:     5 0.2666667  15.000000 2.661759e-05 1.415169e-03\n 7:     7 0.3733333  10.714286 1.744088e-04 7.948056e-03\n 8:    23 1.2266667   4.891304 5.028363e-04 2.005060e-02\n 9:     9 0.4800000   8.333333 5.876141e-04 2.082765e-02\n10:    10 0.5333333   7.500000 9.473756e-04 3.022128e-02\n\n\nBecause I don’t have much time left, I will have ChatGPT explain the logic, probably much better than I will. Perhaps will update it sometime.\nHere’s the whole workflow in plain language, with the “why” behind each move.\nFirst, we define two sets of genes. The universe (also called background or population) is the pool of all genes we consider “possible draws” for our analysis. In your exercise, we made the universe be all ORF IDs present in your node table (e.g., YLR131C). We did this because the gene sets we’ll test (from MSigDB) are also in ORF format; using the same ID system everywhere avoids silent mismatches. The target is the list of genes you’re curious about—in this case, the genes in Cluster 1. Conceptually, over-representation asks: “If I randomly drew the same number of genes from the universe, how often would I hit genes from a given function? Is my target list hitting that function more often than chance?”\nNext, we fetch Gene Ontology gene sets with the msigdbr package. GO has three “trunks”: Biological Process (BP) for sequences of events like DNA replication, Molecular Function (MF) for activities like ATP binding, and Cellular Component (CC) for places like the nucleus. msigdbr() returns a data frame where each row links one gene set name (gs_name) to one gene (ensembl_gene here means yeast ORF IDs). The over-representation function fgsea::fora() does not want a data frame, though—it wants a named list mapping each gene set to a vector of its genes. We create that with split(BP_df$ensembl_gene, BP_df$gs_name), which literally groups all genes by their set names. Because statistics must reflect the space you’re drawing from, we then clean each gene set to your universe using intersect(): if a gene isn’t in your background, we drop it from the set. That way, each set’s size truly means “how many genes in your universe belong to this set.”\nWith inputs aligned, we run fora(pathways = BP_list, genes = target, universe = universe). For every gene set, fora builds a 2×2 table (in-target vs out-of-target × in-set vs out-of-set) and uses Fisher’s exact test to compute a p-value (is the overlap bigger than expected by chance?). It also applies multiple-testing correction (Benjamini–Hochberg) so you get padj, which is the column you should rank by. The output includes: the gene set name (pathway), size (how many universe genes are in that set), and overlap (how many of your target genes hit that set).\nBecause raw p-values don’t tell effect size, we add expected and enrichment. The expected number of hits in your target for a set is:\nexpected = (set size / universe size) × target size.\nThis is the “random draw” prediction. The enrichment is observed / expected = overlap / expected. If enrichment ≫ 1, your target list contains that function far more than chance would predict. We then sort results by padj (and break ties with pval) to see the most statistically convincing terms first, and report the top 10 for BP, MF, and CC.\nTwo practical details matter a lot in the real world. First, ID consistency: your target, your universe, and your gene sets must use the same identifier namespace (we standardized on yeast ORFs like YMR078C). Any mismatch quietly erases overlaps. Second, data hygiene: we dropped a single NA in Cluster 1’s IDs because you can’t match a missing identifier to any set; even one NA can break the “all(target %in% universe)” check. Finally, the choice of universe changes p-values (and sometimes conclusions). For coursework, using the node table’s IDs is fine and consistent; in research, you’d justify a broader universe (e.g., all expressed genes in your assay) to avoid bias.\n\nAnd that will be all for today!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Systems Biology",
    "section": "",
    "text": "This is my personal site for the course Introduction to Systems Biology (BSc/MSc).\nI’m collecting my exercise solutions here. The code isn’t meant to be perfect—it’s a working record of my learning process, to consolidate material and maybe help others following along.\n\n\n\nIn this course, we cover three arcs: foundations of network analysis, core systems biology workflows, and applied biomedical use-cases.\n\n\n\n\nWhy networks for biological problems\n\nBasics of network analysis\n\nTopology, key metrics, community detection\n\n\n\n\n\nFunctional regulation components\n\nVisualizing regulatory networks\n\nTranscriptomics on networks\n\nTime-series + networks → regulatory modes\n\n\n\n\n\nMulti-species PPI → inferred human interactome\n\nVirtual pulldowns & relevance-scored networks\n\nProtein isoforms in systems biology\n\nDisease-focused molecular network analysis\n\n\n\n\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n\n\nVirtual Pulldown\n\nNetwork Characterization\n\nDisease case study\n\n\n\nOverall objective: learn how to extract meaningful networks from human PPI data\n\n\n\nSep 25, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGene Ontology\n\nEnrichment Analysis\n\nfgsea\n\n\n\n\n\n\n\nSep 18, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNetwork topology\n\nClustering\n\nAdvanced Visualization\n\n\n\n\n\n\n\nSep 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBasics\n\nVisualization\n\n\n\nLearn the basics of network visualization with igraph for systems biology.\n\n\n\nSep 4, 2025\n\n\n\n\n\n\nNo matching items\nQuarto is pretty nice."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Introduction to Systems Biology",
    "section": "",
    "text": "This is my personal site for the course Introduction to Systems Biology (BSc/MSc).\nI’m collecting my exercise solutions here. The code isn’t meant to be perfect—it’s a working record of my learning process, to consolidate material and maybe help others following along."
  },
  {
    "objectID": "index.html#course-outline",
    "href": "index.html#course-outline",
    "title": "Introduction to Systems Biology",
    "section": "",
    "text": "In this course, we cover three arcs: foundations of network analysis, core systems biology workflows, and applied biomedical use-cases.\n\n\n\n\nWhy networks for biological problems\n\nBasics of network analysis\n\nTopology, key metrics, community detection\n\n\n\n\n\nFunctional regulation components\n\nVisualizing regulatory networks\n\nTranscriptomics on networks\n\nTime-series + networks → regulatory modes\n\n\n\n\n\nMulti-species PPI → inferred human interactome\n\nVirtual pulldowns & relevance-scored networks\n\nProtein isoforms in systems biology\n\nDisease-focused molecular network analysis"
  },
  {
    "objectID": "index.html#all-notebooks",
    "href": "index.html#all-notebooks",
    "title": "Introduction to Systems Biology",
    "section": "",
    "text": "Virtual Pulldown\n\nNetwork Characterization\n\nDisease case study\n\n\n\nOverall objective: learn how to extract meaningful networks from human PPI data\n\n\n\nSep 25, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGene Ontology\n\nEnrichment Analysis\n\nfgsea\n\n\n\n\n\n\n\nSep 18, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNetwork topology\n\nClustering\n\nAdvanced Visualization\n\n\n\n\n\n\n\nSep 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBasics\n\nVisualization\n\n\n\nLearn the basics of network visualization with igraph for systems biology.\n\n\n\nSep 4, 2025\n\n\n\n\n\n\nNo matching items"
  }
]