---
title: "Week 3: Gene Ontology"
date: 2025-09-18
description: ""
categories: [Gene Ontology, Enrichment Analysis, fgsea]
image: images/week3.png
format:
  html: default
editor: visual
---

```{r}
library(tidyverse)
library(fgsea)
library(msigdbr)
```

## Goals:

Today we will start working with GSEA!

1.  Understand how Gene Ontology terms are defined and organized:

    -   The relationship between GO terms (IS A, PART OF, etc)
    -   The three main trunks of GO: BIOLOGICAL PROCESS, MOLECULAR FUNCTION and CELLULAR COMPONENT.

2.  Learn how to query the Gene Ontology database.

    -   Using the official online GO query system: AmiGO
    -   Using links from UniProt.

3.  Understand the theory behind GO over-representation analysis

4.  Learn how to perform GO over-representation analysis:

    -   Using the R package "fgsea"

**First, we will investigate "cell division" using** [AmiGO 2](http://amigo.geneontology.org).

By clicking on "Graph views", we can open QuickGO and see how many ancestor and children terms are defined, as well as the different types of relationships they have.

***GO has a few relationship categories.*** For more information, you can browse the exercises here and do the non-coding exercises to get a feel for the categories: <https://teaching.healthtech.dtu.dk/22140/index.php/ExGeneOntology_R>. ***But here is an LLM-generated outline:***

### üß¨ Structural Relationships

### `is_a` ‚Äî ‚Äúa type of‚Äù

This is the simplest one.\
Think of it like saying **‚ÄúX is a more specific type of Y.‚Äù**

-   **Example:**

    -   **GO:0005739 mitochondrion**\
        *is_a* **GO:0043231 intracellular membrane-bounded organelle**

-   Meaning: Every mitochondrion **is** an intracellular membrane-bounded organelle.

**Practical use:** When you annotate a gene to "mitochondrion," it automatically counts as being in "intracellular organelle" too. Tools use this to group related things together.

------------------------------------------------------------------------

### `part_of` ‚Äî ‚Äúalways contained within‚Äù

This says that **wherever X exists, it‚Äôs part of Y.**

-   **Example:**

    -   **GO:0000776 kinetochore**\
        *part_of* **GO:0000775 chromosome, centromeric region**

-   Meaning: Whenever a kinetochore exists, it‚Äôs sitting inside the centromeric region of a chromosome.

**Practical use:** If you see genes annotated to "kinetochore," you can infer they‚Äôre also involved with the centromeric chromosome structure, even if not directly annotated.

------------------------------------------------------------------------

### `has_part` ‚Äî ‚Äúalways contains‚Äù

This is the opposite: **if Y exists, it contains X as a piece.**

-   **Example:**

    -   **GO:0005840 ribosome**\
        *has_part* **GO:0003735 structural constituent of ribosome**

-   Meaning: Every ribosome **has** some structural ribosomal proteins inside.

**Practical use:** This is used more for reasoning than annotation, but helps ontology tools understand what structures are made of.

------------------------------------------------------------------------

## ‚öôÔ∏è Functional / Process Relationships

### `regulates` ‚Äî ‚Äúinfluences how much / how fast‚Äù

This links processes that **control other processes**.

-   **Example:**

    -   **GO:0048523 negative regulation of cellular process**\
        *regulates* **GO:0009987 cellular process**

-   Meaning: This is a process that dials down (inhibits) some cellular process.

**Practical use:** If your gene is involved in regulation, it may not directly perform the target process ‚Äî it‚Äôs a controller, not a worker.

------------------------------------------------------------------------

### `positively_regulates` / `negatively_regulates`

These are more specific kinds of `regulates`.

-   **Example:**

    -   **GO:0043065 positive regulation of apoptotic process**\
        *positively_regulates* **GO:0006915 apoptotic process**

-   Meaning: This process **boosts** apoptosis.\
    (And conversely, ‚Äúnegative regulation‚Äù **blocks** it.)

**Practical use:** Helps distinguish activators vs. inhibitors of the same pathway in analysis.

------------------------------------------------------------------------

### `occurs_in` ‚Äî ‚Äúhappens inside‚Äù

This ties a **process** to a **location**.

-   **Example:**

    -   **GO:0006260 DNA replication**\
        *occurs_in* **GO:0005634 nucleus**

-   Meaning: DNA replication takes place in the nucleus (in eukaryotes).

**Practical use:** Lets you connect dynamic events to the cell structures they happen in.

------------------------------------------------------------------------

### `capable_of` ‚Äî ‚Äúcan do this‚Äù

This says a **structure can perform a function or process.**

-   **Example:**

    -   **GO:0005665 DNA-directed RNA polymerase II, core complex**\
        *capable_of* **GO:0003899 DNA-directed RNA polymerase activity**

-   Meaning: This protein complex **can do** the activity of RNA polymerase.

**Practical use:** Connects physical complexes (what something **is**) to what they **do**.

------------------------------------------------------------------------

### üß† Logical Notes

-   GO is structured as a **Directed Acyclic Graph (DAG)**: terms can have multiple parents.

-   Relationships define the logical inference engine used by GO tools (like enrichment analysis and ontology reasoners).

-   Not all relationships are used in all GO branches; e.g. `regulates` is only used in **biological process** branch, while `capable_of` links **cellular components** to **functions** or **processes**.

------------------------------------------------------------------------

# Part 2: Gene Ontology overrepresentation analysis (ORA)

```{r}
# Here I just import the exercise data.
cluster <- read_csv2("data/clusterexGO.csv")
bg_terms <- read_csv2("data/background_countsexGO.csv")
bg_total <- 5500

cluster
bg_terms

# nrow is a base R function that tells the number of rows, in my case it is the number of proteins in the cluster -- 16.
n <- nrow(cluster)
n

# Now we will sum up all the columns. To understand what this does, you have to know the structure of the table. we have a protein X, and then the association of that protein X with three columns GO terms, namely DNA replication (GO:0006260), DNA repair (GO:0006281), Cell cycle (GO:0007049), denoted by 1 (yes, associated) and 0 (no, not associated). So when we sum up all the columns we get the number of proteins in the cluster that are associated with a given GO term. 

observed <- colSums(cluster[, c("DNA_replication", "DNA_repair", "Cell_cycle")])
observed

# bg_terms has the total number of proteins listed that are involved in the three GO categories "DNA replication", "DNA repair" and "Cell cycle" across the entire genome.

# %>% is the pipe operator from the tidyverse. It means take the thing on the left and pass it into the function on the right. 

# mutate() adds a new column to the data frame or overwrites an existing one. 

# So here we‚Äôre creating a new column called freq_bg. Inside mutate(), freq_bg = bg_count / bg_total means: divide the number of genes annotated to the term (bg_count) by the total number of background genes (bg_total = 5500). So as a result, for each GO term, we now have the genome-wide frequency.

bg_terms <- bg_terms %>%
  mutate(freq_bg = bg_count / bg_total)

# See the new column.
bg_terms

# Now we do the same -- add a new column, but that column is now the number of expected proteins associated with a given GO term in a randow draw of 16 proteins (n).

bg_terms <- bg_terms %>%
  mutate(expected = freq_bg * n)
bg_terms

# Here we add the observed (colSums) column to the table matched by name of GO term. 
bg_terms <- bg_terms %>%
  mutate(observed = observed[term])
bg_terms

# So enrichment is simply the number of observed divided by the number of expected, which we calculated earlier. Reminder: expected is a decimal, but not a proportion!

bg_terms <- bg_terms %>%
  mutate(enrichment = observed/expected)
bg_terms
```

Now we will build a table like that for each GO term to perform the [Fischer's exact test](https://en.wikipedia.org/wiki/Fisher%27s_exact_test).

|                   | In cluster (n=16) | Not in cluster (5500 ‚àí 16)    |
|-------------------|-------------------|-------------------------------|
| **Annotated**     | a = observed      | c = bg_count ‚àí observed       |
| **Not annotated** | b = n ‚àí observed  | d = (bg_total ‚àí bg_count) ‚àí b |

Where:

-   **a** = how many cluster genes had the term (observed).

-   **b** = how many cluster genes did *not* have the term.

-   **c** = how many background genes (outside your cluster) had the term.

-   **d** = the rest (background genes without the term, excluding your cluster).

```{r}

# Observed associated with DNA replication
a <- observed["DNA_replication"]
# Number of proteins in cluster NOT associated with DNA replication
b <- n - a
# "c" is the number of DNA replication genes OUTSIDE the cluster

# Step 1:bg_terms$bg_count[] looks up how many DNA replication genes exist in the whole genome (in this case: 96 total). On the operator $: bg_terms$bg_count means: ‚ÄúFrom the data frame bg_terms, give me the column named bg_count.‚Äù. when we specify bg_terms$term == "DNA_Replication", we get the bg_count of dna_replication.

# Step 2: subtract "a", the ones we already counted inside the cluster. That leaves only the ones not in the cluster.
c <- bg_terms$bg_count[bg_terms$term == "DNA_replication"] - a

# here the login is the same, but it is the number of genes that in the whole genome are NOT associated with dna replication minus the genes in the cluster that are not associated with DNA replication.

d <- (bg_total - bg_terms$bg_count[bg_terms$term == "DNA_replication"]) - b

# Here we create the table mentioned above.
m <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
            dimnames = list(c("has_term","no_term"),
                            c("in_cluster","not_in_cluster")))

m

# alternative = "greater" sets the direction of the hypothesis test.
# "greater" = test if the GO term is over-represented in the cluster.
# (Other options: "less" tests under-representation; "two.sided" tests either way.)

fisher.test(m, alternative = "greater")

```

-   p-value \< 2.2e-16 is the probability this enrichment happened by chance is effectively zero.

-   alternative hypothesis -\> we asked if the term is over-represented (so odds ratio \> 1), and the test says yes.

-   95% confidence interval (122.089 ‚Äì Inf) -\> the real effect is at least 122x, maybe higher (upper bound open).

-   odds ratio 457.4204 -\> genes in the cluster are about 457 times more likely to have this GO term than random genes in the genome.

Now lets repeat this for the other two GO terms!

```{r}
# DNA repair
a <- observed["DNA_repair"]
b <- n - a
c <- bg_terms$bg_count[bg_terms$term == "DNA_repair"] - a
d <- (bg_total - bg_terms$bg_count[bg_terms$term == "DNA_repair"]) - b

m_repair <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
            dimnames = list(c("has_term","no_term"),
                            c("in_cluster","not_in_cluster")))

fisher.test(m_repair, alternative = "greater")

# Cell cycle
a <- observed["Cell_cycle"]
b <- n - a
c <- bg_terms$bg_count[bg_terms$term == "Cell_cycle"] - a
d <- (bg_total - bg_terms$bg_count[bg_terms$term == "Cell_cycle"]) - b

m_cycle <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
            dimnames = list(c("has_term","no_term"),
                            c("in_cluster","not_in_cluster")))

fisher.test(m_cycle, alternative = "greater")


```

So here we can see that for DNA repair p is 2.8e-10, so extremely significant odds ratio of 35. Cluster genes are about 35 times more likely to be DNA repair genes than random genes!

Cell cycle p = 8.7e-7, and a highly significant odds ratio of 17. Cluster genes are about 17 times more likely to be cell cycle genes than random genes.

So all three GO terms are significantly enriched in the cluster.

## Automated analysis using "fgsea" and "msigdbr"

Here are a few tips from ChatGPT before we start:

-   `msigdbr(...)` returns a **data frame** with columns like `gs_name` (gene set name) and `ensembl_gene` (gene IDs).

-   `fgsea::fora()` expects **pathways as a named list**: `list(GENESET1 = c(g1, g2, ...), GENESET2 = c(...))`.

-   Therefore: **you cannot feed the msigdbr data frame directly** to `fora()`. You must convert it with `split()`.

-   Also, your **target** and **background** IDs must be in the **same ID namespace** as the gene sets (we‚Äôll use Ensembl-like yeast ORFs; your `ID` column looks good).

### ü™ê "Universe" (background)

-   The **universe** is the **full set of all genes you could possibly draw from**.

-   It‚Äôs also called the **background list** or **population group**.

-   In your case, it‚Äôs the `background` object you loaded from `exercise3_part2.Rdata` ‚Äî a list of **all annotated yeast genes**.

-   `fora()` uses it to figure out what ‚Äúrandom chance‚Äù looks like.\
    If 100 out of 5500 genes are DNA repair genes, that‚Äôs the baseline probability.

So:\
**Universe = all yeast genes.**\
**Target = your cluster 1 genes.**

```{r}
load("data/exercise3_part1.Rdata")

load("data/exercise3_part2.Rdata")

# From now on, I will personally need a lot of help from ChatGPT, but I will try to decipher everything as well.

# This command retrieves biological process gene sets for yeast. The "C5" category is the msigdb annotation for the three gene ontologies. The subcategory is either "BP" (biological process), "MF" (molecular function), or "CC" (cellular component).

# Here we take BP (biological process)

BP_df = msigdbr(species = "S. cerevisiae", category = "C5", subcategory = "BP")

# Inspect structure and a few rows
dim(BP_df)          # how many rows & columns?
names(BP_df)        # column names available
head(BP_df[, c("gs_name","ensembl_gene")], 5)   # key columns we‚Äôll use

BP_list = split(x = BP_df$ensembl_gene, f = BP_df$gs_name)

# Inspect to see what one looks like
length(BP_list)          # number of gene sets
names(BP_list)[1:5]       # first few set names
head(BP_list[[1]], 10)    # genes inside first set

# Universe: all genes that are "possible draws" for this analysis.
# We take them from the node table's ORF IDs so they match msigdbr's ORF IDs.
universe <- unique(node_attributes$ID)   # unique() removes duplicates

# Then clean BP sets to that universe
clean_sets <- function(pathways, universe){
  sets <- lapply(pathways, function(g) intersect(unique(g), universe))
  sets[vapply(sets, length, integer(1)) > 0]
}
BP_list <- clean_sets(BP_list, universe)

# Quick sanity peek:
length(universe)     # How big is the universe? (a count)
head(universe, 5)    # What do these IDs look like? Should be Yxxx... style


# Target: the actual genes we're testing for enrichment (Cluster #1).
# Boolean filter: keep rows where the 'cluster' column equals the label "cluster1",
# then pull their ORF IDs and drop duplicates.
target <- unique(node_attributes$ID[node_attributes$cluster == "cluster1"])

# Quick sanity peek:
length(target)       # How many genes are in Cluster #1?
head(target, 5)      # Do these look like ORF IDs too?

# Sanity checks that prevent nonsense results:
sum(is.na(target))                    # should be 0 (no missing IDs in target)
all(target %in% universe)             # should be TRUE (every target in the universe)

# ‚ö†Ô∏è Problem ‚Äî one of your target entries is NA. That means at least one row in cluster1 had a missing ID.

# Removing it: 

target <- target[!is.na(target)]

# Rechecking: 

length(target)
all(target %in% universe)

# Run over-representation for BP
res_bp <- fora(pathways = BP_list,   # named list: set -> vector of ORF IDs
               genes    = target,    # your cluster-1 ORF IDs
               universe = universe)  # all possible ORF IDs (background)

# See what columns we got back
names(res_bp)        # should include: pathway, pval, padj, size, overlap
head(res_bp, 5)      # quick peek at the first rows

add_enrichment <- function(res, universe, target){
  expected   <- (res$size / length(universe)) * length(target)  # random-draw expectation
  enrichment <- res$overlap / expected                          # effect size (observed/expected)
  out <- cbind(res, expected = expected, enrichment = enrichment)
  out[order(out$padj, out$pval), ]                              # rank by adjusted p-value
}

res_bp <- add_enrichment(res_bp, universe, target)

# Show top-10 BP terms for your report
top10_bp <- head(res_bp[, c("pathway","overlap","size","expected","enrichment","pval","padj")], 10)
top10_bp

```

Now we just repeat the same for CC and MF:

```{r}
# Get MF & CC from msigdbr
MF_df <- msigdbr(species = "S. cerevisiae", category = "C5", subcategory = "MF")
CC_df <- msigdbr(species = "S. cerevisiae", category = "C5", subcategory = "CC")

# Convert to lists
MF_list <- split(MF_df$ensembl_gene, MF_df$gs_name)
CC_list <- split(CC_df$ensembl_gene, CC_df$gs_name)

# Clean to your universe
MF_list <- clean_sets(MF_list, universe)
CC_list <- clean_sets(CC_list, universe)

# Run fora
res_mf <- fora(MF_list, target, universe)
res_cc <- fora(CC_list, target, universe)

# Add enrichment and take top 10
res_mf  <- add_enrichment(res_mf, universe, target)
res_cc  <- add_enrichment(res_cc, universe, target)

top10_mf <- head(res_mf[, c("pathway","overlap","size","expected","enrichment","pval","padj")], 10)
top10_cc <- head(res_cc[, c("pathway","overlap","size","expected","enrichment","pval","padj")], 10)

top10_mf
top10_cc

```

Because I don't have much time left, I will have ChatGPT explain the logic, probably much better than I will. Perhaps will update it sometime.

Here‚Äôs the whole workflow in plain language, with the ‚Äúwhy‚Äù behind each move.

First, we define two sets of genes. The **universe** (also called background or population) is the pool of all genes we consider ‚Äúpossible draws‚Äù for our analysis. In your exercise, we made the universe be **all ORF IDs present in your node table** (e.g., `YLR131C`). We did this because the gene sets we‚Äôll test (from MSigDB) are also in ORF format; using the same ID system everywhere avoids silent mismatches. The **target** is the list of genes you‚Äôre curious about‚Äîin this case, the genes in **Cluster 1**. Conceptually, over-representation asks: ‚ÄúIf I randomly drew the same number of genes from the universe, how often would I hit genes from a given function? Is my target list hitting that function *more often than chance*?‚Äù

Next, we fetch **Gene Ontology** gene sets with the `msigdbr` package. GO has three ‚Äútrunks‚Äù: **Biological Process (BP)** for sequences of events like DNA replication, **Molecular Function (MF)** for activities like ATP binding, and **Cellular Component (CC)** for places like the nucleus. `msigdbr()` returns a **data frame** where each row links one gene set name (`gs_name`) to one gene (`ensembl_gene` here means yeast ORF IDs). The over-representation function `fgsea::fora()` does not want a data frame, though‚Äîit wants a **named list** mapping each gene set to a vector of its genes. We create that with `split(BP_df$ensembl_gene, BP_df$gs_name)`, which literally groups all genes by their set names. Because statistics must reflect the space you‚Äôre drawing from, we then **clean** each gene set to your universe using `intersect()`: if a gene isn‚Äôt in your background, we drop it from the set. That way, each set‚Äôs **size** truly means ‚Äúhow many genes in *your* universe belong to this set.‚Äù

With inputs aligned, we run `fora(pathways = BP_list, genes = target, universe = universe)`. For every gene set, `fora` builds a 2√ó2 table (in-target vs out-of-target √ó in-set vs out-of-set) and uses **Fisher‚Äôs exact test** to compute a **p-value** (is the overlap bigger than expected by chance?). It also applies **multiple-testing correction** (Benjamini‚ÄìHochberg) so you get **`padj`**, which is the column you should rank by. The output includes: the gene set name (`pathway`), **`size`** (how many universe genes are in that set), and **`overlap`** (how many of your target genes hit that set).

Because raw p-values don‚Äôt tell effect size, we add **expected** and **enrichment**. The **expected** number of hits in your target for a set is:\
`expected = (set size / universe size) √ó target size`.\
This is the ‚Äúrandom draw‚Äù prediction. The **enrichment** is `observed / expected = overlap / expected`. If enrichment ‚â´ 1, your target list contains that function far more than chance would predict. We then sort results by `padj` (and break ties with `pval`) to see the most statistically convincing terms first, and report the **top 10** for BP, MF, and CC.

Two practical details matter a lot in the real world. First, **ID consistency**: your target, your universe, and your gene sets must use the **same identifier namespace** (we standardized on yeast ORFs like `YMR078C`). Any mismatch quietly erases overlaps. Second, **data hygiene**: we dropped a single `NA` in Cluster 1‚Äôs IDs because you can‚Äôt match a missing identifier to any set; even one NA can break the ‚Äúall(target %in% universe)‚Äù check. Finally, the **choice of universe** changes p-values (and sometimes conclusions). For coursework, using the node table‚Äôs IDs is fine and consistent; in research, you‚Äôd justify a broader universe (e.g., all expressed genes in your assay) to avoid bias.\

And that will be all for today!